# **Sistemas Operacionais**  ## **Estrutura de um S.O. (Parte 1\\)**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br  ### **Sistema Operacional: Conjunto de serviços**  **\\[Imagem: Diagrama da estrutura de um sistema computacional\\]**  *A imagem exibe um diagrama em camadas. Na base está o \\\"hardware\\\". Acima do hardware, uma grande caixa representa o \\\"operating system\\\" (sistema operacional). Dentro desta caixa, há uma camada de \\\"services\\\" (serviços) que inclui: execução de programas, operações de E/S, sistemas de arquivos, comunicação, detecção de erros, alocação de recursos, contabilidade e proteção e segurança. Acima da camada de serviços, dentro da mesma caixa do SO, está a camada de \\\"system calls\\\" (chamadas de sistema). No topo, acima do sistema operacional, está a camada \\\"user and other system programs\\\" (usuário e outros programas de sistema), que se comunica com o SO através das \\\"user interfaces\\\" (interfaces do usuário), divididas em \\\"GUI\\\" (Interface Gráfica do Usuário), \\\"batch\\\" (lote) e \\\"command line\\\" (linha de comando).*  ### **Sistema Operacional: Conjunto de serviços**  * **Interface com o usuário**     * Quase todos SO possuem uma interface com o usuário.     * Variam entre linha de Comando, Interface Gráfica e Lote (Batch).   * **Execução de Programas**     * O sistema deve ser capaz de carregar um programa em memória e terminar sua execução, normalmente ou inesperadamente (indicando algum erro).   * **Operações de E/S**     * Um programa em execução pode requerer E/S, que pode envolver um arquivo ou dispositivo de E/S.   * **Manipulação do Sistema de Arquivos**     * Os programas necessitam ler e escrever em arquivos e diretórios, criar e removê-los, pesquisá-los, listar informações de arquivos e gerenciar permissões.  ### **Sistema Operacional: Conjunto de serviços**  * **Comunicação**     * Processos podem trocar informações, no mesmo computador ou entre computadores numa rede. A comunicação pode ser entre memória compartilhada ou através de passagem de mensagens (pacotes movidos pelo SO).   * **Detecção de Erros**     * O SO necessita estar constantemente informado de possíveis erros. Podem ocorrer no hardware da CPU ou memória, em dispositivos de E/S, ou um programa do usuário.     * Para cada tipo de erro, o SO deve tomar a ação adequada para assegurar a computação correta e consistente.     * Facilidades de depuração podem melhorar significativamente a capacidade de usuários e programadores usarem o sistema de forma eficiente.  ### **Sistema Operacional: Conjunto de serviços**  * **Alocação de Recursos**     * Quando vários usuários ou vários jobs executam concorrentemente, recursos devem ser alocados para cada um deles. Muitos tipos de recursos. Alguns (Ciclos de CPU, memória principal e armazenamento de arquivos) podem ter código de alocação especial, enquanto outros (tais como dispositivos de E/S) podem ter código de pedido e liberação muito mais geral.   * **Contabilização (Accounting)**     * Para manter informação sobre quais usuários usaram quanto e quais tipos de recursos do computador.  ### **Sistema Operacional: Conjunto de serviços**  * **Proteção** envolve a garantia de que todo acesso a recursos do sistema é controlado.   * **Segurança** do sistema contra acesso de pessoas estranhas requer autenticação de usuário, estende-se à defesa dos dispositivos de E/S e a manutenção do registro de todas conexões para detecção de invasões.   * Se um sistema deve ser protegido e seguro, precauções devem ser instituídas como um todo.   * \\\"Uma corrente é tão forte quanto o seu elo mais fraco\\\".  ### **Sistema Operacional: Interface de usuário \\- Linha de comando (CLI)**  * Uma interface de Linha de Comando ou interpretador de comandos permite a entrada direta de comandos.   * Algumas vezes implementadas no kernel, outras vezes por programas do sistema.   * Algumas vezes, implementado em de múltiplas maneiras \\- shells.   * Aceita um comando do usuário e o executa.   * Se implementado como programa do sistema, a adição de novas funcionalidades não requer modificação do shell.  ### **Sistema Operacional: Interface de usuário \\- Gráfica (GUI)**  * Interface desktop amigável ao usuário (user-friendly).   * Normalmente, permite a utilização de mouse, teclado e monitor.   * Ícones representam arquivos, programas, ações, etc.   * Vários botões do mouse sobre objetos na interface ocasionam diversas ações (fornecem informações, opções, executam funções, abrem diretórios (também conhecidos como pastas)).   * Inventada no Xerox PARC.  ### **Sistema Operacional: Interface de usuário \\- Gráfica (GUI)**  * Muitos sistemas atuais incluem tanto interfaces de linha de comando quanto GUI.   * Microsoft Windows possui GUI e o shell conhecido como \\\"command\\\".   * Apple Mac OS X possui Interface GUI \\\"Aqua\\\" com UNIX Kernel subjacente e shells disponíveis.   * Solaris possui interface de linha de comando com interfaces gráficas opcionais (Java Desktop, KDE).  **\\[Imagem: Captura de tela de um terminal Linux\\]**  *A imagem mostra duas janelas de terminal em um sistema operacional semelhante ao Unix (Solaris). A janela superior exibe estatísticas de dispositivos (extended device statistics). A janela inferior exibe a execução de vários comandos de linha: swap \\-sh (mostrando o uso de memória de troca), uptime (mostrando há quanto tempo o sistema está ligado e a média de carga) e w (mostrando os usuários logados e o que estão fazendo).*  **\\[Imagem: Captura de tela da interface gráfica do MAC OS X\\]**  *A imagem exibe a interface gráfica do sistema operacional Mac OS X. Várias janelas estão abertas, incluindo o Finder (gerenciador de arquivos), a Calculadora, o Dicionário e o Catálogo de Endereços. O plano de fundo é a imagem de uma galáxia. A doca na parte inferior da tela mostra ícones de vários aplicativos. A interface é caracterizada por seu design com sombras, transparências e ícones detalhados.*  **\\[Imagem: Capturas de tela das interfaces gráficas GNOME e KDE\\]**  *A imagem é uma colagem de duas interfaces gráficas para sistemas Linux. À esquerda, a interface GNOME, com um painel superior, ícones na área de trabalho e um menu de aplicações. À direita, a interface KDE, também com um painel (neste caso, na parte inferior), um menu principal (\\\"K\\\"), e várias janelas de aplicativos abertas, mostrando uma aparência distinta do GNOME.*  ### **Sistema Operacional: Classificação**  Podem ser classificados de acordo com:  1. **Características básicas de arquitetura do sistema:** Monolítico, Microkernel, em Camadas ou Máquina virtual;   2. **Capacidade de executar tarefas:** Monotarefa ou Multitarefa; e   3. **Quantidade de usuários que podem operar o sistema:** Monousuário ou Multiusuário.  ### **Sistema Operacional: Classificação \\- Arquitetura: Monolítico**  Todos os componentes do núcleo operam em modo núcleo e se inter-relacionam sem restrições de acesso entre si.  **\\[Imagem: Diagrama da arquitetura monolítica\\]**  *O diagrama mostra a arquitetura monolítica. Na base, a camada \\\"hardware\\\". Acima, uma grande caixa chamada \\\"núcleo\\\", que representa o \\\"nível núcleo\\\". Dentro desta caixa, vários círculos (componentes do SO) estão interligados por setas de forma não estruturada, indicando que todos podem se comunicar com todos. No topo, no \\\"nível usuário\\\", caixas de \\\"aplicação\\\" se comunicam com os componentes do núcleo.*  ### **Sistema Operacional: Classificação \\- Arquitetura: Monolítico**  **\\[Imagem: Diagrama de modos de operação na arquitetura monolítica\\]**  *Este diagrama simplificado mostra uma \\\"Aplicação\\\" no \\\"Modo Usuário\\\" que faz \\\"System Calls\\\" (chamadas de sistema) para o \\\"núcleo\\\", que opera em \\\"Modo Kernel\\\". O núcleo, por sua vez, interage com o \\\"Hardware\\\".*  ### **Sistema Operacional: Classificação \\- Arquitetura: Monolítico**  * É construído como uma coleção de rotinas onde cada uma pode chamar qualquer outra.   * **A grande vantagem** dessa arquitetura é seu desempenho: qualquer componente do núcleo pode acessar os demais componentes, toda a memória ou mesmo dispositivos periféricos diretamente, pois não há barreiras impedindo esse acesso.   * **Desvantagem:** caso um componente do núcleo perca o controle devido a algum erro, esse problema pode se alastrar rapidamente por todo o núcleo, levando o sistema ao colapso (travamento, reinicialização ou funcionamento errático).  ### **Sistema Operacional: Classificação \\- Arquitetura: Monolítico**  * A manutenção e evolução do núcleo se tornam mais complexas, porque as dependências e pontos de interação entre os componentes podem não ser evidentes.   * A arquitetura monolítica foi a primeira forma de organizar os sistemas operacionais.   * Sistemas UNIX antigos e o MS-DOS seguiam esse modelo. Atualmente, sistemas operacionais embutidos usam essa arquitetura, devido às limitações do hardware sobre o qual executam.  ### **Sistema Operacional: Classificação \\- Arquitetura: Microkernel**  * Possui separação de funções chamadas Servidores \\- Consiste em retirar do núcleo todo o código de alto nível (normalmente associado às políticas de gerência de recursos), deixando no núcleo somente o código de baixo nível necessário para interagir com o hardware e criar as abstrações fundamentais (como a noção de atividade).   * Por exemplo, usando essa abordagem o código de acesso aos blocos de um disco rígido seria mantido no núcleo, enquanto as abstrações de arquivo e diretório seriam criadas e mantidas por um código fora do núcleo, executando da mesma forma que uma aplicação do usuário.   * Por fazer os núcleos de sistema ficarem menores, essa abordagem foi denominada micro-núcleo (ou microkernel).  ### **Sistema Operacional: Classificação \\- Arquitetura: Microkernel**  As interações entre componentes e aplicações são feitas através de trocas de mensagens. Os processos não podem se comunicar diretamente, devido às restrições impostas pelos mecanismos de proteção do hardware. Todas as mensagens são transmitidas através de serviços do micronúcleo. Como os processos têm de solicitar \\\"serviços\\\" uns dos outros, para poder realizar suas tarefas, essa abordagem também foi denominada cliente-servidor.  **\\[Imagem: Diagrama da arquitetura microkernel\\]**  *O diagrama ilustra a arquitetura microkernel. Na base está o \\\"hardware\\\". Acima, a camada \\\"kernel mode\\\" contém o \\\"microkernel\\\", que inclui apenas \\\"Interprocess Communication\\\", \\\"memory managment\\\" e \\\"CPU scheduling\\\". Acima, na camada \\\"user mode\\\", estão componentes como \\\"Application Program\\\", \\\"File System\\\" e \\\"Device Driver\\\", que rodam como processos separados e se comunicam com o microkernel e entre si através de \\\"messages\\\" (mensagens).*  ### **Sistema Operacional: Classificação \\- Arquitetura: Microkernel**  **\\[Imagem: Outro diagrama da arquitetura microkernel\\]**  *Este diagrama mostra uma visão diferente. Na base, o \\\"Micro-núcleo\\\" no \\\"Nível núcleo\\\". Acima dele, no \\\"Nível usuário\\\", estão vários processos servidores: \\\"Gerente de memória\\\", \\\"Gerente de proteção\\\", \\\"Gerente de discos\\\", \\\"Gerente de arquivos\\\". No topo, também no nível usuário, estão as \\\"aplicações\\\" que interagem com esses gerentes.*  ### **Sistema Operacional: Classificação \\- Arquitetura: Microkernel**  * Os micronúcleos foram muito investigados durante os anos 80\\. Dois exemplos clássicos dessa abordagem são os sistemas Mach e Chorus.   * As principais vantagens dos sistemas micro-núcleo são sua **robustez** e **flexibilidade**: caso um subsistema tenha problemas, os mecanismos de proteção de memória e níveis de privilégio irão confiná-lo, impedindo que a instabilidade se alastre ao restante do sistema.   * Vários sistemas operacionais atuais adotam parcialmente essa estruturação; por exemplo, o MacOS X da Apple tem suas raízes no sistema Mach. Assim como o Minix e o Symbian.   * O QNX é um dos poucos exemplos de micronúcleo amplamente utilizado, sobretudo em sistemas embarcados e de tempo-real.  ### **Sistema Operacional: Classificação \\- Arquitetura: em Camadas**  * O sistema operacional é dividido em um número de camadas (níveis), cada uma construída no topo das outras camadas. A camada inferior (camada 0), é o hardware; a camada mais alta (camada N) é a interface com o usuário.   * Com a modularização, as camadas são selecionadas de tal forma que cada uma use as funções (operações) e serviços das camadas de nível inferior.  **\\[Imagem: Diagrama da arquitetura em camadas\\]**  *A imagem mostra uma série de círculos concêntricos. O círculo central é a \\\"layer 0 hardware\\\". Envolvendo-o, está a \\\"layer 1\\\". Seguem-se outras camadas (representadas por \\\"...\\\") até a camada mais externa, \\\"layer N user interface\\\".*  ### **Sistema Operacional: Classificação \\- Arquitetura: em Camadas**  * Essa abordagem de estruturação de software fez muito sucesso no domínio das redes de computadores, através do modelo de referência OSI (Open Systems Interconnection), e também seria de se esperar sua adoção no domínio dos sistemas operacionais.   * Muitos sistemas implementam uma camada inferior de abstração do hardware para interagir com os dispositivos (a camada HAL – Hardware Abstraction Layer, implementada no Windows NT e seus sucessores), e também organizam em camadas alguns subsistemas como a gerência de arquivos e o suporte de rede (seguindo o modelo OSI).  ### **Sistema Operacional: Classificação \\- Arquitetura: em Camadas**  * No entanto, alguns inconvenientes limitam sua aceitação nesse contexto:     * O empilhamento de várias camadas de software faz com que cada pedido de uma aplicação demore mais tempo para chegar até o dispositivo periférico ou recurso a ser acessado, prejudicando o desempenho do sistema.     * Não é óbvio como dividir as funcionalidades de um núcleo de sistema operacional em camadas horizontais de abstração crescente, pois essas funcionalidades são interdependentes, embora tratem muitas vezes de recursos distintos.  ### **Sistema Operacional: Classificação \\- Arquitetura: em Camadas**  * Em decorrência desses inconvenientes, a estruturação em camadas é apenas parcialmente adotada hoje em dia.   * Como exemplos de sistemas fortemente estruturados em camadas podem ser citados o OpenVMS, IBM OS/2 e o MULTICS.  ### **Sistema Operacional: Classificação \\- Arquitetura: em Camadas**  **\\[Imagem: Diagramas de camadas dos sistemas Multics e VMS\\]**  A imagem mostra dois exemplos de arquitetura em camadas:   Sistema Multics (à esquerda): Uma pirâmide de camadas. De baixo para cima: Kernel (Camada 0: Multiprogramação, Camada 1: Gerência de Memória), Executivo (Camada 2: Comunicação), Supervisor (Camada 3: Entrada/Saída), e no topo, Camada 4: Programas de Usuário e Camada 5: Operador.   Sistema VMS (à direita): Um diagrama similar, mas não é claramente legível no documento original.  ### **Sistema Operacional: Classificação \\- Arquitetura: Máquina virtual**  * Uma máquina virtual leva a abordagem em camadas para sua conclusão lógica. Ela trata o hardware e o kernel do sistema operacional como se eles fossem em conjunto um hardware.   * Uma máquina virtual pode fornecer uma interface idêntica ao hardware subjacente exposto. O Sistema operacional hospedeiro cria a ilusão que um processo possui seu próprio processador e sua própria memória (virtual).   * Cada sistema operacional convidado disponibilizado com uma cópia (virtual) do computador subjacente (ou partes dele).  ### **Sistema Operacional: Classificação \\- Arquitetura: Máquina virtual**  * Apareceram comercialmente em mainframes IBM em 1972\\.   * Fundamentalmente, múltiplos ambientes de execução (diferentes sistemas operacionais) podendo compartilhar o mesmo hardware.   * Proteção mútua entre os sistemas operacionais.   * Compartilhamento de arquivos pode ser permitido e controlado.  ### **Sistema Operacional: Classificação \\- Arquitetura: Máquina virtual**  * Comunicam-se umas com as outras, inclusive sistemas físicos via rede.   * Útil para desenvolvimento e testes.   * O padrão \\\"Formato de Máquina Virtual Aberta \\- Open Virtual Machine Format\\\", permite uma máquina virtual executar dentro de muitas plataformas diferentes de máquinas virtuais (host).  ### **Sistema Operacional: Classificação \\- Arquitetura: Máquina virtual**  **\\[Imagem: Diagramas de máquina não-virtual vs. virtual\\]**  A imagem mostra duas configurações:   (a) Máquina não-virtual: Os processos rodam sobre uma interface de programação que interage diretamente com o kernel, que por sua vez interage com o hardware.   (b) Máquina virtual: Sobre o hardware, há uma implementação de máquina virtual. Sobre ela, rodam três VMs (VM1, VM2, VM3). Cada VM tem seu próprio kernel e seus próprios processos, operando de forma isolada das outras.   **\\[Imagem: Arquitetura VMWare\\]**  *O diagrama mostra a arquitetura de virtualização do VMWare. Na base está o hardware (CPU, memória, dispositivos de E/S). Acima dele, há um sistema operacional hospedeiro (host), como o Linux. Sobre o host, roda a \\\"virtualization layer\\\" (camada de virtualização). Essa camada permite a criação de múltiplas máquinas virtuais (neste caso, FreeBSD, Windows NT, Windows XP), cada uma com sua própria CPU virtual, memória virtual, dispositivos virtuais e seu próprio sistema operacional convidado (guest). As aplicações rodam dentro desses sistemas convidados.*  **\\[Imagem: Arquitetura da JVM (Java Virtual Machine)\\]**  *O diagrama ilustra o funcionamento da JVM. Arquivos de programa Java (.class) são carregados pelo \\\"class loader\\\", que também carrega as APIs Java (.class). O \\\"Java interpreter\\\" executa esse código sobre um \\\"host system\\\" (como Windows ou Linux).*  ### **Sistema Operacional: Classificação \\- Arquitetura: Máquina virtual**  **\\[Imagem: Diagrama comparando abstração e virtualização\\]**  A imagem compara dois conceitos:   Abstração (esquerda): Um software interage com um arquivo, que é uma abstração de um dispositivo de armazenamento físico (disco). A interação permite apenas operações simples.   Virtualização (direita): Um software interage com um arquivo (que pode representar um disco virtual), que por sua vez interage com o dispositivo de armazenamento físico. A virtualização permite operações complexas, dando ao software a ilusão de que ele tem acesso total a um hardware completo.   **\\[Imagem: Diagrama mostrando o poder da virtualização com várias camadas\\]**  \\*O diagrama mostra um hardware (x86) na base. Sobre ele, rodam diferentes tecnologias de virtualização e sistemas operacionais em paralelo:  * Uma Aplicação Java rodando na JVM.   * Um sistema Linux completo rodando dentro do User-Mode Linux (UML).   * Um sistema Windows rodando dentro do VMware.     Tudo isso sobre um sistema operacional Linux hospedeiro.\\*  **\\[Imagem: Diagrama mostrando o poder da virtualização com diferentes tecnologias\\]**  \\*Este diagrama mais complexo mostra um hardware x86 na base. Sobre ele, várias tecnologias de virtualização permitem rodar diferentes sistemas e aplicações simultaneamente:  * FreeBSD com aplicações em Jails.   * Mac OS com aplicações Mac.   * VMware rodando Windows.   * QEMU rodando Windows.   * Xen rodando Linux.   * UML rodando Linux.   * JVM rodando uma aplicação.\\*  **\\[Imagem: Diagrama dos recursos de uma Máquina Virtual\\]**  *A imagem ilustra uma única máquina virtual. Ela é composta por um Sistema Operacional sobre o qual rodam várias aplicações (app). O sistema operacional interage com um conjunto de \\\"Virtual Machine Resources\\\" (Recursos da Máquina Virtual), que incluem representações virtuais de CPU, memória, disco, placas de rede e vídeo, controlador SCSI, mouse, CD/DVD e teclado.*  **\\[Imagem: Diagrama da camada de virtualização VMware\\]**  *A imagem mostra a arquitetura de virtualização da VMware. Na base, há a \\\"x86 Architecture\\\" (CPU, Memória, NIC, Disco). Acima, a \\\"VMware Virtualization Layer\\\" cria duas máquinas virtuais isoladas. Cada uma tem seu próprio Sistema Operacional e suas próprias Aplicações, e enxerga um conjunto virtual de hardware.*  **\\[Imagem: Mosaico de capturas de tela do VirtualBox\\]**  *A imagem mostra um mosaico de janelas do software Oracle VM VirtualBox. Cada janela está executando uma versão diferente do sistema operacional Windows (XP, Vista, 7, 8, 8.1) para testar diferentes versões do navegador Internet Explorer (IE7, IE8, IE10, IE11).*  **\\[Imagem: Comparação de sistema com e sem virtualização\\]**  A imagem compara duas abordagens:   Sem Virtualização: Uma única Aplicação roda sobre um único Sistema Operacional, que tem acesso direto ao Hardware.   Com Virtualização: Sobre o Hardware, roda o \\\"ESX Server\\\" (uma camada de virtualização). Ele permite que múltiplos Sistemas Operacionais, cada um com sua Aplicação, rodem em paralelo, compartilhando o mesmo hardware.   **\\[Imagem: Logos de softwares de virtualização\\]**  *A imagem exibe os logotipos de vários softwares e tecnologias de virtualização populares: Oracle VM VirtualBox, Parallels, QEMU e VMware.*  ### **Sistema Operacional: Classificação \\- Tarefas: Monotarefa**  * Um sistema monotarefa ou monoprogramado executa uma tarefa de cada vez (serial).   * Permite que o processador, a memória e os periféricos permaneçam exclusivamente dedicados à execução de um único programa.   * Recursos são mal utilizados, entretanto são implementados com facilidade. Ociosidade devido a I/O-bound ou CPU-bound.   * Possíveis estados dos processos: Novo \\- Execução – Término.  ### **Sistema Operacional: Classificação \\- Tarefas: Multitarefa**  * Um sistema multitarefa ou multiprogramado executa várias tarefas simultaneamente (concorrente) e subdivide-se em:     a) Sistemas de tempo compartilhado (time sharing systems);     b) Sistemas de tempo real.   * Pode manter vários programas em memória ao mesmo tempo.   * Execução de várias tarefas em um único processador: enquanto uma está em execução, as outras estão em espera (I/O-bound).   * Troca de contexto é uma operação que ocorre nos sistemas multitarefa quando se altera o programa que está sendo executado.  ### **Sistema Operacional: Classificação \\- Usuários: Monousuário versus Multiusuário**  * Um sistema monousuário não faz distinção entre os usuários, foi projetado para ser utilizado por um único usuário.   * Um sistema multiusuário permite diversos usuários garantindo a separação e não interferência entre as tarefas de cada um.  ### **Sistema Operacional: Outras classificações**  * Outro tipo de classificação está relacionada a diversos parâmetros e perspectivas, como tamanho, velocidade, suporte a recursos específicos, acesso à rede, etc.   * A seguir são apresentados alguns tipos de sistemas operacionais usuais (muitos sistemas operacionais se encaixam bem em mais de uma das categorias apresentadas nos slides a seguir).  ### **Sistema Operacional: Outras classificações**  * **Batch (de lote):** os sistemas operacionais mais antigos trabalhavam \\\"por lote\\\", ou seja, todos os programas a serem executados eram colocados em uma fila, com seus dados e demais informações para a execução. O processador recebia os programas e os processava sem interagir com os usuários, o que permitia um alto grau de utilização do sistema.   * Atualmente, este conceito se aplica a sistemas que processam tarefas sem interação direta com os usuários, como os sistemas de processamento de transações em bancos de dados.  **\\[Imagem: Diagrama do processamento em lote (Batch)\\]**  O diagrama mostra o fluxo do processamento em lote em três etapas:   (a) Vários \\\"jobs\\\" (representados como cartões perfurados) são lidos e gravados sequencialmente em uma \\\"fita de entrada\\\".   (b) A fita de entrada é processada, gerando uma \\\"fita de saída\\\".   (c) A fita de saída é lida para gerar \\\"relatórios\\\" impressos.  ### **Sistema Operacional: Outras classificações**  * **De rede:** um sistema operacional de rede deve possuir suporte à operação em rede, ou seja, a capacidade de oferecer às aplicações locais recursos que estejam localizados em outros computadores da rede, como arquivos e impressoras. Ele também deve disponibilizar seus recursos locais aos demais computadores, de forma controlada.   * A maioria dos sistemas operacionais atuais oferece esse tipo de funcionalidade.  ### **Sistema Operacional: Outras classificações**  * **Distribuído:** em um sistema operacional distribuído, os recursos de cada máquina estão disponíveis globalmente, de forma transparente aos usuários. Ao lançar uma aplicação, o usuário interage com sua janela, mas não sabe onde ela está executando ou armazenando seus arquivos: o sistema é quem decide, de forma transparente.   * Os sistemas operacionais distribuídos já existem há tempos (Amoeba e Clouds, por exemplo), mas ainda não são uma realidade de mercado.  ### **Sistema Operacional: Outras classificações**  * **Servidor:** um sistema operacional servidor deve permitir a gestão eficiente de grandes quantidades de recursos (disco, memória, processadores), impondo prioridades e limites sobre o uso dos recursos pelos usuários e seus aplicativos.   * Normalmente um sistema operacional servidor também tem suporte a rede e multi-usuários.  ### **Sistema Operacional: Outras classificações**  * **Embarcado:** um sistema operacional é dito embarcado ou embutido (embedded) quando é construído para operar sobre um hardware com poucos recursos de processamento, armazenamento e energia. Aplicações típicas desse tipo de sistema aparecem em telefones celulares, controladores industriais e automotivos, equipamentos eletrônicos de uso doméstico (leitores de DVD, TVs, fornos-micro-ondas, centrais de alarme, etc.). Muitas vezes um sistema operacional embutido se apresenta na forma de uma biblioteca a ser ligada ao programa da aplicação (que é fixa).   * Exemplos de sistemas operacionais embutidos são o C/OS, LynxOS e VxWorks.  ### **Sistema Operacional: Outras classificações**  * **Tempo real:** ao contrário da concepção usual, um sistema operacional de tempo real não precisa ser necessariamente ultra-rápido; sua característica essencial é ter um comportamento temporal previsível (ou seja, seu tempo de resposta deve ser conhecido no melhor e pior caso de operação).   * A estrutura interna de um sistema operacional de tempo real deve ser construída de forma a minimizar esperas e latências imprevisíveis, como tempos de acesso a disco e sincronizações excessivas.  ### **Sistema Operacional: Outras classificações**  * **Tempo real (cont.):** Existem duas classificações de sistemas de tempo real:     * **Soft real-time systems:** nos quais a perda de prazos implica na degradação do serviço prestado. Um exemplo seria o suporte à gravação de CDs ou à reprodução de músicas.     * **Hard real-time systems:** a perda de prazos pelo sistema pode perturbar o objeto controlado, com graves consequências humanas, econômicas ou ambientais. Por exemplo, o controle de funcionamento de uma turbina de avião a jato ou de uma caldeira industrial.   * Exemplos de sistemas de tempo real incluem o QNX, RT-Linux e VxWorks.  ### **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4ª ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 1\\.     * Link: [https://plataforma.bvirtual.com.br/Acervo/Publicacao/1233](https://plataforma.bvirtual.com.br/Acervo/Publicacao/1233)   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3ª ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 1\\.     * Link: [https://plataforma.bvirtual.com.br/Acervo/Publicacao/315](https://plataforma.bvirtual.com.br/Acervo/Publicacao/315)