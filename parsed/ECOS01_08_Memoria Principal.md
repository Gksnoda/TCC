\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Gerenciamento de Memória**  ### **Memória Principal**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Gerenciamento de Memória**  * O gerenciamento de memória tem por objetivos:     1. Oferecer uma área de armazenamento para os processos;     2. Proteger os processos contra falhas de terceiros; e     3. Prover um desempenho satisfatório aos usuários.   * Deseja-se também compartilhamento de memória entre processos e acesso transparente à memória.  \\--- PÁGINA 3 \\---  ## **Gerenciamento de Memória**  * Idealmente, os programadores desejam uma memória que seja:     * Grande     * Rápida     * Não-volátil     * De baixo custo  \\--- PÁGINA 4 \\---  ## **Tipos de memória**  \\[Imagem: Diagrama de tipos de memória\\]   Um diagrama de árvore mostrando a classificação da memória do computador. A Primary Memory (volátil) se divide em RAM (SRAM, DRAM) e ROM (PROM, EPROM, EEPROM). A Secondary Memory (não-volátil) inclui HDD, SSD, Compact Disk, Floppy Disk e Magnet Tape.   \\--- PÁGINA 5 \\---  ## **Gerenciamento de Memória**  \\[Imagem: Hierarquia de Memória Simplificada\\]   Uma pirâmide da hierarquia de memória, do mais rápido e caro no topo ao mais lento e barato na base: PROCESSOR REGISTER, CPU CACHE, PHYSICAL MEMORY (RAM), SOLID STATE MEMORY, VIRTUAL MEMORY.   \\--- PÁGINA 6 \\---  ## **Gerenciamento de Memória**  \\[Imagem: Detalhes da Hierarquia de Memória\\]   Uma ilustração mais detalhada da hierarquia de memória, mostrando os tempos de acesso típicos e custos relativos, desde os registradores (nanossegundos) até as fitas magnéticas (minutos).   \\--- PÁGINA 7 \\---  ## **Gerenciamento de Memória: Novas tecnologias**  \\[Imagem: Novas tecnologias na hierarquia de memória\\]   Um diagrama mostrando como novas tecnologias como Optane DC Persistent memory e 3D NAND SSD estão se encaixando na hierarquia de memória tradicional, preenchendo as lacunas entre a DRAM e o armazenamento em disco.   \\--- PÁGINA 8 \\---  ## **Gerenciamento de Memória: GOAL: EFFICIENT DATA CENTRIC ARCHITECTURE**  \\[Imagem: Arquitetura Centrada em Dados\\]   Um gráfico mostrando a frequência de acesso aos dados (\\\"Hot data\\\" vs \\\"Cooler data\\\") sobreposto a uma pirâmide de hierarquia de armazenamento. O objetivo é otimizar o desempenho, movendo os dados mais quentes (acessados com frequência) para camadas de armazenamento mais rápidas (mais perto da CPU).   \\--- PÁGINA 9 \\---  ## **Gerenciamento de Memória: Tarefas**  * Gerenciar a hierarquia de memória:     * Espaços livres e ocupados;     * Localizar e alocar processos e dados na memória.   * Controlar as partes da memória (mapeamento) que estão em uso para:     * Alocar processos quando estes precisarem;     * Liberar memória quando um processo terminar;     * Tratamento de **swapping** \\- processo responsável por gerenciar o chaveamento entre a memória principal e o disco.  \\--- PÁGINA 10 \\---  ## **Gerenciamento de Memória: Monoprogramação**  * Somente um programa na memória principal.  \\[Imagem: Modelos de Monoprogramação\\]   Três diagramas mostrando diferentes layouts de memória em sistemas monoprogramados: (1) SO em ROM, (2) SO em RAM (parte inferior), (3) SO e drivers em RAM (parte inferior).   \\--- PÁGINA 11 \\---  ## **Gerenciamento de Memória: Multiprogramação**  * Divisão da memória em n partições de tamanho fixo, não necessariamente iguais;   * Filas (simples ou múltiplas) para o controle e execução dos jobs.  \\[Imagem: Particionamento Fixo\\]   Dois diagramas mostrando o particionamento fixo da memória. A memória é dividida em partições de tamanhos pré-definidos. Os processos de uma fila de entrada são alocados a uma partição que os comporte.   \\--- PÁGINA 12 \\---  ## **Gerenciamento de Memória: Multiprogramação \\- Vinculação de endereços**  * Usualmente, um programa reside em um disco como um arquivo binário executável.   * Para ser executado, o programa deve ser trazido para a memória e inserido dentro de um processo.   * Os processos em disco que estão esperando para serem trazidos à memória para execução formam a **fila de entrada**.  \\--- PÁGINA 13 \\---  ## **Gerenciamento de Memória: Vinculação de endereços**  \\[Imagem: Passos da vinculação de endereços\\]   Um fluxograma mostrando as fases de vinculação de um programa: compile time (compilador gera um módulo objeto), load time (o loader carrega o programa na memória) e execution time (onde pode ocorrer ligação dinâmica com bibliotecas do sistema).   \\--- PÁGINA 14 \\---  ## **Gerenciamento de Memória: Multiprogramação**  * Como fornecer a cada programa seu próprio espaço de endereçamento?   * **Solução:** 2 registradores: **base** e **limite**.  \\[Imagem: Proteção de Memória com Base e Limite\\]   Diagrama mostrando a proteção de memória. A CPU gera um endereço que é verificado pela MMU. Se o endereço for maior ou igual ao registrador base e menor que base \\+ limit, o acesso à memória é permitido. Caso contrário, uma interrupção (trap) é gerada.   \\--- PÁGINA 15 \\---  ## **Gerenciamento de Memória: Endereços Físicos versus Endereços Lógicos**  * Um endereço gerado pela CPU é comumente referenciado como **endereço lógico**, enquanto um endereço visto pela unidade de memória é referenciado como **endereço físico**.  \\--- PÁGINA 16 \\---  ## **Gerenciamento de Memória: Endereços Físicos versus Endereços Lógicos**  * **Endereço lógico:** gerado pela CPU (virtual, posição relativa).   * **Endereço físico:** visto pela unidade de memória (real).  \\[Imagem: Tradução de Endereço com Registrador de Relocação\\]   Diagrama mostrando uma MMU que soma o endereço lógico (346) gerado pela CPU com o valor de um relocation register (14000) para produzir o endereço físico (14346).   \\--- PÁGINAS 17-18 \\---  ## **Gerenciamento de Memória: Endereços Físicos versus Endereços Lógicos**  * Os métodos de vinculação de endereços em tempo de compilação e em tempo de carga geram endereços lógicos e físicos idênticos.   * O esquema de vinculação de endereços em tempo de execução resulta em endereços lógicos e físicos diferentes. Nesse caso, usualmente referenciamos o endereço lógico como um **endereço virtual**.  \\--- PÁGINA 19 \\---  ## **Gerenciamento de Memória: Unidade de Gerenciamento de Memória (MMU)**  * Endereços lógicos são transformados.   * Tabela de tradução.   * Registrador de relocação.  \\--- PÁGINA 20 \\---  ## **Gerenciamento de Memória: Multiprogramação \\- Memory Management Unit (MMU)**  * Dispositivo (hardware) que transforma endereços virtuais/lógicos em endereços físicos.  \\[Imagem: Papel da MMU\\]   Um diagrama mostrando a CPU gerando um virtual address. A MMU (que pode conter um TLB) traduz esse endereço para um physical address, que é usado para acessar a Main Memory.   \\--- PÁGINA 21 \\---  ## **Gerenciamento de Memória: Vinculação de endereços (ligação)**  * Dependendo da linguagem, do S.O. e do HW, há diversos momentos onde a associação entre os comandos e a memória pode acontecer:     * Tempo de compilação     * Tempo de carga     * Tempo de execução  \\--- PÁGINAS 22-24 \\---   Estes slides detalham cada um dos tempos de vinculação de endereços.   \\--- PÁGINAS 25-27 \\---  ## **Gerenciamento de Memória: Carga Dinâmica**  * Permite que partes de um programa só sejam carregados na memória quando chamados.   * Melhor utilização da memória.   * Uma rotina não é carregada até ser chamada. O programa principal é carregado e, quando chama outra rotina, o carregador relocável é invocado para carregar a rotina desejada.  \\--- PÁGINA 28 \\---  ## **Gerenciamento de Memória: Ligação Dinâmica**  * Vinculação de endereços postergada até a execução.   * Pequeno trecho de código (**stub**) ocupa o lugar do acesso não vinculado.   * Ao ser executado, o stub localiza a rotina correta e substitui a si mesmo com o código correto.   * Particularmente útil para bibliotecas compartilhadas.  \\--- PÁGINA 29 \\---  ## **Swapping: Permuta de processos**  \\--- PÁGINA 30 \\---  ## **Gerenciamento de Memória: Swapping \\- Permuta de processos**  * É o chaveamento de processos entre a memória e o disco:     * **Swap-out:** da memória para o disco, para uma área de swap.     * **Swap-in:** do disco para a memória.  \\[Imagem: Processo de Swapping\\]   Diagrama mostrando o processo P₁ sendo movido da memória principal (main memory) para o disco (backing store) no passo swap out, e o processo P₂ sendo movido do disco para a memória no passo swap in.   \\--- PÁGINA 31 \\---  ## **Gerenciamento de Memória: Swapping \\- Permuta de processos**  * Processos inteiros podem ser transferidos temporariamente para memória secundária e posteriormente trazidos de volta.   * Requer uma “memória de retaguarda\\\" (backing store) grande o suficiente.   * Maior overhead é o tempo de transferência.   * Presente em diversos S.O. (Unix, Linux, Win...).  \\--- PÁGINA 32 \\---   Este slide repete a imagem de Swapping, adicionando uma ilustração sobre fragmentação.   \\--- PÁGINAS 33-34 \\---   Estes slides detalham o processo de swapping padrão e explicam por que ele não é comumente usado em sistemas móveis (devido ao uso de memória flash).   \\--- PÁGINA 35 \\---  ## **Partições**  \\--- PÁGINA 36 \\---  ## **Gerenciamento de Memória: Partições**  * **Partições fixas (ou alocação estática):**     * Tamanho e número de partições são fixos.     * Tendem a desperdiçar memória.     * Mais simples.   * **Partições variáveis (ou alocação dinâmica):**     * Tamanho e número de partições variam.     * Otimiza a utilização da memória, mas torna complexa a alocação e liberação.     * Menor fragmentação interna e maior fragmentação externa.  \\--- PÁGINA 37 \\---  ## **Gerenciamento de Memória: Fragmentação externa e interna**  * **Fragmentação** é a quebra do espaço em frações não utilizáveis.   * **Fragmentação externa:** Memória não utilizada dividida em muitos buracos, pequenos demais para serem úteis.   * **Fragmentação interna:** Limitações na forma como blocos são alocados podem gerar buracos dentro do bloco alocado.  \\--- PÁGINA 38 \\---  ## **Gerenciamento de Memória: Partições**  \\[Imagem: Criação de Fragmentação Externa\\]   Uma sequência de diagramas mostrando como a alocação e liberação de processos (A, B, C, D) em partições variáveis pode levar à criação de pequenos buracos de memória não contíguos entre os processos, caracterizando a fragmentação externa.   \\--- PÁGINAS 39-40 \\---   Estes slides mostram mais exemplos gráficos de fragmentação externa e interna.   \\--- PÁGINA 41 \\---  ## **Gerenciamento de Memória: Fragmentação externa**  \\[Imagem: Compactação de Memória\\]   Uma sequência de diagramas mostrando o problema da fragmentação externa sendo resolvido pela compactação, que move todos os processos alocados para um lado da memória, unindo todos os pequenos buracos em um único grande bloco de memória livre.   \\--- PÁGINA 42 \\---  ## **Gerenciamento de Memória: Fragmentação externa e interna**  * **Solução para a fragmentação externa: Compactação**     * Mover blocos ocupados para perto uns dos outros.     * Só é possível com relocação dinâmica.   * Outra forma de lidar com fragmentação externa é permitir alocação não contígua (**paginação** ou **segmentação**).  \\--- PÁGINAS 43-45 \\---  ## **Gerenciamento de Memória: Alocação contígua**  *Estes slides descrevem a alocação contígua, onde cada processo ocupa um único bloco contíguo de memória física, e como ela funciona em um ambiente com múltiplos processos.*  \\--- PÁGINA 46 \\---  ## **Gerenciamento de espaço**  \\--- PÁGINA 47 \\---  ## **Gerenciamento de Memória: Estruturas para gerenciamento de espaço**  * **Mapa de bits (Bitmaps):** A memória é dividida em unidades de alocação. Cada unidade corresponde a um bit no bitmap: 0 para livre, 1 para ocupado.   * **Lista Encadeada:** É mantida uma lista encadeada de segmentos de memória livres e alocados.  \\--- PÁGINA 48 \\---   Este slide mostra um exemplo comparativo de como a mesma situação de memória seria representada por um Bitmap e por uma Lista Encadeada.   \\--- PÁGINA 49 \\---  ## **Gerenciamento de Memória: Algoritmos de alocação**  * **Primeira escolha (first-fit):** Percorre a lista até que encontre o primeiro slot em que caiba a informação.   * **Melhor escolha (best-fit):** Busca a lista inteira e toma a menor partição que comporte o processo.   * **Pior escolha (worst-fit):** Busca a lista inteira para a maior partição.   * **Próxima escolha (next-fit):** Similar ao primeira escolha, mas percorre a lista a partir do último valor inserido.  \\--- PÁGINAS 50-53 \\---  ## **Memória Virtual**  *Estes slides introduzem o conceito de Memória Virtual, explicando que é uma técnica que usa a memória secundária para estender a memória principal, permitindo executar programas maiores que a RAM e aumentando o grau de multiprogramação. As duas principais técnicas, **Paginação** e **Segmentação**, são apresentadas.*  \\--- PÁGINA 54 \\---  ## **Segmentação**  \\--- PÁGINAS 55-56 \\---  ## **Gerenciamento de Memória: Segmentação**  * A segmentação é um esquema de gerenciamento de memória que dá suporte à visão da memória do programador.   * Um espaço de endereçamento lógico é um conjunto de segmentos (ex: código, dados, pilha).   * Um endereço lógico é uma dupla: \\<número\\_segmento, deslocamento\\>.   * Uma **tabela de segmentos** mapeia cada segmento para um endereço físico (base \\+ limite).  \\--- PÁGINA 57 \\---   \\[Imagem: Segmentação Lógica vs. Física\\]   A imagem mostra que a visão lógica do programador (um único espaço de endereço com pilha, heap, dados e código) é mapeada para segmentos não contíguos na memória física.   \\--- PÁGINAS 58-60 \\---   Estes slides mostram a estrutura de hardware para segmentação e exemplos de mapeamento de endereços lógicos para físicos, incluindo o compartilhamento de segmentos (como um editor de texto) entre processos.   \\--- PÁGINA 61 \\---  ## **Paginação**  \\--- PÁGINAS 62-63 \\---  ## **Gerenciamento de Memória: Paginação**  * A paginação evita a fragmentação externa.   * A memória física é dividida em blocos de tamanho fixo chamados **frames**.   * A memória lógica é dividida em blocos de mesmo tamanho chamados **páginas**.   * Uma **tabela de páginas** é usada para mapear as páginas virtuais de um processo para os frames na memória física.  \\--- PÁGINA 64 \\---  ## **Gerenciamento de Memória: Paginação**  * **Page fault:** é o evento que ocorre quando uma página referenciada não está na RAM. O SO deve então trazê-la do disco.   * **Tabela de páginas:** estrutura para mapear uma página ao frame correspondente \\- cada processo possui uma.  \\--- PÁGINAS 65-68 \\---   Estes slides detalham o processo de tradução de endereço na paginação e mostram exemplos visuais de como a tabela de páginas mapeia o espaço de endereçamento lógico para a memória física.   \\--- PÁGINA 69 \\---   Este slide mostra como a alocação de páginas para um novo processo ocorre, utilizando uma lista de frames livres (free-frame list).   \\--- PÁGINAS 70-71 \\---  ## **Gerenciamento de Memória: Paginação \\- Componentes do endereço**  * **Endereço Virtual:** é dividido em **Número de página (p)** e **Deslocamento (d)**.   * O número da página é usado como índice na tabela de páginas para encontrar o número do frame.   * O número do frame é combinado com o deslocamento para formar o endereço físico.  \\--- PÁGINAS 72-76 \\---   Estes slides detalham a estrutura da tabela de páginas, incluindo os bits de controle (proteção, válido-inválido, modificado), e como a proteção de memória é implementada nesse esquema.   \\--- PÁGINA 77 \\---  ## **Gerenciamento de Memória: Segmentação com paginação**  * É possível combinar as duas técnicas e paginar cada segmento.   * Usado no Multics e na arquitetura Intel 386\\.   * Combina a flexibilidade da segmentação com a gestão de memória da paginação.  \\--- PÁGINA 78 \\---   Este slide mostra o complexo esquema de endereçamento do Intel 80386, que combina segmentação e paginação.   \\--- PÁGINA 79 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 3\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 9\\.  \\--- PÁGINA 80 \\---   Slide final com o logo da universidade e contato do professor.