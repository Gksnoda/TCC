\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Gerenciamento de Memória**  ### **Memória Virtual**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Gerenciamento de Memória: Paginação**  * A segmentação permite que o espaço de endereçamento físico de um processo seja não-contíguo. A paginação é outro esquema de gerenciamento da memória que oferece essa vantagem.   * No entanto, a paginação evita a fragmentação externa e a necessidade de compactação, enquanto a segmentação não faz isso.   * Ela também resolve o considerável problema de acomodar trechos de memória de vários tamanhos na memória de retaguarda.  \\--- PÁGINA 3 \\---  ## **Paginação**  \\--- PÁGINA 4 \\---  ## **Gerenciamento de Memória: Paginação**  * Chama-se paginação a técnica utilizada para transferência de dados inativos da memória principal para a secundária (**Page-Out**) e transferência de dados ativos de volta para a memória principal (**Page-In**).   * Algumas páginas não podem ser removidas da memória principal, a exemplo daquelas que armazenam:     * a tabela de paginação;     * rotinas de tratamento de interrupção; e     * informações manipuladas pelos dispositivos com recurso de acesso direto à memória (DMA).  \\--- PÁGINA 5 \\---  ## **Gerenciamento de Memória: Paginação**  * Memória (lógica/física) é dividida em blocos de tamanho fixo \\- potências de 2; p.ex.: 4 KB.   * Blocos lógicos (pages) são mapeadas em blocos físicos (frames) pelo hardware.   * Endereços lógicos contíguos podem estar em páginas diferentes, em quadros não contíguos.   * Quadros vazios são gerenciados.   * Programa de n páginas requer n quadros (quaisquer).   * Fragmentação interna (na última página).  \\--- PÁGINAS 6-7 \\---   Estes slides repetem os diagramas da estrutura de tradução de endereços da MMU com paginação.   \\--- PÁGINA 8 \\---  ## **Gerenciamento de Memória: Paginação**  * **Páginas:** unidades de tamanho fixo no dispositivo secundário.   * **Frames:** unidades correspondentes na memória física (RAM).   * **Page fault:** é o evento quando uma página que não está na RAM é referenciada \\-\\> Utiliza uma trap para carregar ou substituir uma página.   * **Tabela de páginas:** estrutura para mapear uma página ao frame correspondente \\- cada processo possui uma.  \\--- PÁGINA 9 \\---  ## **Tabela de páginas**  \\--- PÁGINA 10 \\---  ## **Gerenciamento de Memória: Tabela de páginas**  * **Onde armazenar as tabelas?**     * **Array de registradores:** se a memória for pequena. Mantidos no hardware.     * **Memória RAM:** a MMU gerencia utilizando alguns registradores.     * **Cache na MMU:** chamada de memória associativa **(TLB)**.       * TLB \\- Translation Lookaside Buffer       * Utilizada para melhorar o desempenho da tabela na RAM.  \\--- PÁGINAS 11-12 \\---  ## **Gerenciamento de Memória: Tabela de páginas**  * **Tabela na RAM**     * Utiliza dois registradores:       * **Registrador de base da tabela de página (PTBR):** Aponta para o início da tabela.       * **Registrador de tamanho da tabela de página (PTLR):** Indica o tamanho da tabela.     * **Problema:** Dois acessos à memória para cada instrução/dado (um para a tabela, outro para o dado em si).  \\--- PÁGINA 13 \\---  ## **Gerenciamento de Memória: Tabela de páginas**  * **Solução:** cache denominado TLB.  \\--- PÁGINA 14 \\---  ## **Gerenciamento de Memória: Paginação \\- Tempo de acesso efetivo**  * Consulta à TLB: ε   * Tempo de um ciclo de memória: t   * Taxa de acerto (hit ratio) na TLB: α   * Tempo de acesso efetivo (TAE):     * TAE \\= (t \\+ ε)α \\+ (2t \\+ ε)(1-α)     * TAE \\= (2 \\- α)t \\+ ε  \\--- PÁGINA 15 \\---  ## **Gerenciamento de Memória: HW de Paginação com TLB**  \\[Imagem: Fluxo de tradução com TLB\\]   Um diagrama mostrando o processo de tradução de endereço com TLB. A CPU gera um endereço lógico. O número da página (p) é procurado primeiro no TLB. Se houver um acerto (TLB hit), o número do frame (f) é obtido rapidamente. Se houver uma falha (TLB miss), a tabela de páginas principal é consultada na memória.   \\--- PÁGINAS 16-19 \\---   Estes slides revisam a proteção de memória com paginação, incluindo os bits de proteção e o bit de válido-inválido para indicar se uma página está ou não presente na memória física.   \\--- PÁGINA 20 \\---  ## **Gerenciamento de Memória: Falha de páginas**  * **Tipos de page faults**     * **Soft miss:** Quando a página referenciada não está na TLB, mas está na RAM. Basta atualizar a TLB.     * **Hard miss:** A página não está na memória física, nem na TLB. É necessário trazer a página do disco à RAM, e então à TLB.  \\[Imagem: Tratamento de Page Fault\\]   Diagrama ilustrando o que acontece em um page fault. A entrada na tabela de páginas indica que a página está no disco (Hard Disk). O SO é acionado para carregar a página do disco para um frame livre na memória física e atualizar a tabela.   \\--- PÁGINA 21 \\---  ## **Gerenciamento de Memória: Falha de páginas**  \\[Imagem: Passos para tratar um Page Fault\\]   Um fluxograma numerado mostrando os passos: 1\\) Referência a um endereço inválido. 2\\) Trap para o SO. 3\\) SO localiza a página no disco. 4\\) SO encontra um frame livre e carrega a página. 5\\) O SO reseta a tabela de páginas. 6\\) A instrução que causou a falha é reiniciada.   \\--- PÁGINAS 22-30 \\---  ## **Como organizar tabelas de páginas?**  *Estes slides discutem o problema de tabelas de páginas muito grandes em sistemas com grande capacidade de memória. São apresentadas estruturas para lidar com isso, como **tabelas hierárquicas (multinível)**, onde a tabela de páginas é ela mesma paginada, criando dois ou mais níveis de tabelas.*  \\--- PÁGINA 31 \\---  ## **Tabela de páginas por hash**  \\--- PÁGINAS 32-33 \\---  ## **Gerenciamento de Memória: Tabela de páginas por hash**  * Uma abordagem comum para manipular espaços de endereçamento de 32 bits é usar uma tabela de páginas com hash.   * O valor do hash é o número da página virtual.   * Cada entrada na tabela de hash contém uma lista encadeada de elementos para lidar com colisões.  \\--- PÁGINA 34 \\---  ## **Tabela de páginas invertida**  \\--- PÁGINAS 35-38 \\---  ## **Gerenciamento de Memória: Tabela de páginas invertida**  * Possui uma entrada por frame na memória física, em vez de uma entrada por página no espaço virtual.   * Cada entrada armazena o PID e o número da página virtual que ocupa aquele frame.   * Reduz a demanda por memória para a tabela, mas aumenta o tempo de busca, pois é preciso pesquisar na tabela para encontrar um frame. O uso de TLB e tabelas de hash ajuda a mitigar esse problema.  \\--- PÁGINA 39 \\---   Este slide mostra uma comparação visual entre uma tabela de páginas tradicional e uma tabela de hash para gerenciar páginas.   \\--- PÁGINA 40 \\---  ## **Busca e alocação de páginas**  \\--- PÁGINA 41 \\---  ## **Gerenciamento de Memória: Busca de páginas**  * **Paginação simples:** Todas as páginas virtuais do processo são carregadas para a memória principal.   * **Paginação por demanda (demand paging):** Processos começam com nenhuma página na memória. Assim que a CPU tenta executar a primeira instrução, gera um page fault. O Sistema Operacional traz a página que falta à memória.  \\--- PÁGINAS 42-44 \\---  ## **Gerenciamento de Memória: Alocação de páginas**  * **Alocação Fixa:** Cada processo tem um número máximo de páginas reais, definido quando o processo é criado.   * **Alocação Dinâmica:** Número máximo de páginas reais alocadas ao processo varia durante sua execução.  \\--- PÁGINA 45 \\---  ## **Paginação: Políticas de substituição e compartilhamento de páginas**  \\--- PÁGINAS 46-50 \\---  ## **Gerenciamento de Memória: Política de substituição de páginas**  * **Local:** Considera apenas as páginas do próprio processo que sofreu o page fault como candidatas à substituição.   * **Global:** Leva em consideração todas as páginas na memória, de todos os processos, como candidatas à substituição.  \\--- PÁGINAS 51-53 \\---  ## **Gerenciamento de Memória: Compartilhamento de páginas**  * É possível compartilhar páginas entre processos, especialmente páginas de código (que são somente leitura).   * Isso economiza memória, pois uma única cópia de uma biblioteca, por exemplo, pode ser mapeada para o espaço de endereço de múltiplos processos.   * O **TLB** pode armazenar **ASIDs (address-space identifiers)** para garantir que processos diferentes não acessem indevidamente as páginas um do outro.  \\--- PÁGINA 54 \\---  ## **Gerenciamento de Memória: Cópia após gravação (Copy-On-Write: COW)**  * Processos recebem referência à mesma página.   * A página (alterável) tem permissão de escrita \\= 0\\.   * Se algum dos processos tenta escrever:     * Ocorre um Page fault → uma nova página/quadro é alocada(o).   * A partir daí, cada processo tem sua cópia.  \\--- PÁGINAS 55-58 \\---  ## **Gerenciamento de Memória: Arquivos mapeados em memória**  * Permite que o conteúdo de um arquivo no disco seja mapeado diretamente no espaço de endereçamento virtual de um processo.   * Simplifica o acesso a arquivos, que podem ser tratados como vetores na memória.   * Permite que processos compartilhem arquivos de forma eficiente.  \\--- PÁGINAS 59-60 \\---  ## **Gerenciamento de Memória: Superlocação de memória**  * Ocorre quando o sistema tenta carregar mais processos do que a memória física pode suportar, levando a uma alta taxa de page faults.   * Se não houver um frame vazio, o SO precisa realizar a **substituição de páginas**.  \\--- PÁGINA 61 \\---  ## **Gerenciamento de Memória: Substituição de páginas**  * Se nenhum quadro estiver livre:     * Encontre uma página que não esteja em uso (**página vítima**).     * Libere o quadro dela (se estiver \\\"suja\\\", ou seja, modificada, salve-a no disco).     * Modifique a tabela de páginas, invalidando a página vítima.     * Carregue a nova página no quadro agora livre.  \\--- PÁGINA 63 \\---  ## **Gerenciamento de Memória: Substituição de páginas**  * **Bit de modificação (ou bit sujo):** Usado para otimizar a substituição. Se o bit está desligado, a página não foi modificada e pode ser simplesmente descartada, sem a necessidade de escrevê-la de volta no disco.   * Substituição de páginas é essencial para a paginação por demanda e completa a separação entre memória física e lógica.  \\--- PÁGINA 64 \\---  ## **Gerenciamento de Memória: Relação entre falhas e nº de quadros disponíveis**  \\[Imagem: Gráfico de Page Faults vs. Frames\\]   Um gráfico mostrando que, em geral, o número de faltas de página (number of page faults) diminui à medida que o número de quadros de memória (number of frames) alocados para um processo aumenta.   \\--- PÁGINA 65 \\---  ## **Gerenciamento de Memória: Trashing**  * Se processos não têm páginas \\\"suficientes\\\", a taxa de erros de página aumenta drasticamente.   * A utilização da CPU diminui, pois os processos estão constantemente esperando por E/S de paginação.   * O SO, vendo a CPU ociosa, pode tentar aumentar o grau de multiprogramação, piorando o problema.   * **Thrashing:** processos estão ocupados apenas fazendo swap de páginas e aguardando na fila do paginador.  \\[Imagem: Gráfico de Thrashing\\]   Um gráfico mostrando a utilização da CPU em função do grau de multiprogramação. A utilização aumenta até um ponto ótimo e depois cai drasticamente, caracterizando o thrashing.   \\--- PÁGINA 66 \\---  ## **Algoritmos de substituição de páginas**  \\--- PÁGINAS 67-68 \\---   Estes slides listam os vários algoritmos de substituição de páginas que serão discutidos: Ótimo, NRU, FIFO, Segunda chance, Relógio, LRU, Working Set, WSClock.   \\--- PÁGINAS 69-70 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo Ótimo**  * Retira da memória a página que levará mais tempo para ser referenciada no futuro.   * Garante a menor taxa de page faults possível.   * Praticamente impossível de se implementar, pois requer conhecimento do futuro. Usado como base de comparação.  \\--- PÁGINAS 71-74 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo Not-Recently Used (NRU)**  * Utiliza dois bits por página: **Referenciada (R)** e **Modificada (M)**.   * As páginas são divididas em 4 classes (de 0 a 3\\) com base nos valores desses bits.   * Quando uma página precisa ser substituída, o algoritmo remove aleatoriamente uma página da classe mais baixa não vazia.  \\--- PÁGINAS 75-76 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo FIFO (First-In First-Out)**  * O SO mantém uma lista de páginas na memória.   * Quando ocorre um page fault, a página que está na memória há mais tempo (a primeira que entrou) é removida.   * Simples, mas pode ser ineficiente, pois uma página importante e frequentemente usada pode ser removida só por ser a mais antiga.  \\--- PÁGINAS 77-80 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo Segunda Chance e Algoritmo do Relógio (Clock)**  * São melhorias do FIFO que usam o bit de referência (R).   * **Segunda Chance:** Se a página mais antiga tem R=1, seu bit R é zerado e ela é movida para o final da fila (ganha uma \\\"segunda chance\\\"). A busca continua.   * **Relógio:** Implementação mais eficiente da Segunda Chance, usando uma lista circular (como um relógio) e um ponteiro, evitando a movimentação de páginas na lista.  \\--- PÁGINAS 81-88 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo Least Recently Used (LRU)**  * Baseia-se na ideia de que páginas usadas recentemente têm alta probabilidade de serem usadas de novo.   * Substitui a página que não foi usada pelo maior período de tempo.   * Oferece bom desempenho, mas é difícil e caro de implementar perfeitamente em hardware ou software (requer manter uma lista ordenada de acessos ou contadores de tempo para cada página).   * **NFU (Not Frequently Used)** com **envelhecimento (aging)** é uma aproximação de software para o LRU.  \\--- PÁGINAS 89-96 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo Working Set**  * Baseia-se no conceito de **localidade de referência**.   * O **working set** de um processo é o conjunto de páginas que ele está utilizando ativamente em um determinado momento.   * A ideia é manter o working set de um processo na memória para minimizar os page faults.   * Se uma página não está no working set (não foi referenciada recentemente), ela é candidata a ser substituída.  \\--- PÁGINAS 97-100 \\---  ## **Gerenciamento de Memória: Algoritmos de substituição de páginas**  ### **Algoritmo Working Set Clock (WSClock)**  * Combina a eficiência do algoritmo do Relógio com a lógica do Working Set.   * Usa uma lista circular como o Relógio, mas verifica a \\\"idade\\\" da página (tempo desde o último uso) além do bit de referência.   * Uma página com R=0 e idade maior que um limiar (τ) é removida.   * Amplamente utilizado por ser uma boa aproximação do LRU com boa performance.  \\--- PÁGINA 101 \\---   Este slide resume a lista de algoritmos de substituição de páginas abordados.   \\--- PÁGINA 102 \\---  ## **Substituição de páginas: Anomalia de Belady**  \\--- PÁGINAS 103-105 \\---  ## **Gerenciamento de Memória: Substituição de páginas – Anomalia de Belady**  * Em alguns algoritmos (notavelmente o FIFO), a taxa de erros de página pode, contraintuitivamente, **aumentar** quando o número de frames alocados a um processo aumenta.   * Isso ocorre porque a sequência de substituição pode mudar de uma forma que remove páginas que seriam necessárias mais tarde.   * Algoritmos como LRU e Ótimo são imunes a esta anomalia.  \\--- PÁGINA 106 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 3\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 10-11.  \\--- PÁGINA 107 \\---   Slide final com o logo da universidade e contato do professor.