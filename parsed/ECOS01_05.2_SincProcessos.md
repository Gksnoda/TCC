\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Sincronização de Processos**  ### **Parte 2**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Seção crítica: Propostas de Solução**  * Espera ocupada (busy waiting)   * Sleep / WakeUp (primitivas \\- chamadas de sistema)   * Semáforos (variável de controle)   * Monitores (primitiva de alto nível)   * Troca de Mensagens  \\--- PÁGINA 3 \\---   Este slide repete a lista de Propostas de Solução da página 2, destacando \\\"Sleep / WakeUp\\\".   \\--- PÁGINA 4 \\---  ## **Sleep e WakeUp**  * A primitiva sleep() é uma chamada de sistema que bloqueia o processo que a chamou, ou seja, suspende a execução de tal processo até que outro processo o \\\"acorde\\\" (via wakeup), evitando a espera ocupada;   * A primitiva wakeup() é uma chamada de sistema que “acorda” um determinado processo.  \\--- PÁGINA 5 \\---  ## **Sleep e WakeUp**  Problema que pode ser solucionado com o uso dessas primitivas: **Problema do Produtor/Consumidor (bounded buffer)**: dois processos compartilham um buffer de tamanho fixo (limitado).  * O processo produtor coloca dados no buffer e o processo consumidor retira dados do buffer.  \\[Imagem: Problema do Produtor-Consumidor\\]   Um diagrama mostrando múltiplos producers colocando itens (A, B, C, D) em um bounded buffer with capacity N e múltiplos consumers retirando esses itens.   \\--- PÁGINA 6 \\---  ## **Sleep e WakeUp**  Problema do Produtor/Consumidor:  * **Problemas:**     * Produtor deseja colocar dados quando o buffer ainda está cheio;     * Consumidor deseja retirar dados quando o buffer está vazio;   * **Solução:** colocar os processos para \\\"dormir\\\", até que eles possam ser executados.  \\--- PÁGINA 7 \\---  ## **Sleep e WakeUp: Implementação**  * **Buffer:** Uma variável count controla a quantidade de dados presente no buffer.   * **Produtor:** Antes de colocar dados no buffer, verifica o valor de count.     * Se a variável está com valor máximo, o processo produtor é colocado para dormir.     * Caso contrário, o produtor coloca dados no buffer e incrementa count.   * **Consumidor:** Antes de retirar dados do buffer, verifica se count é maior do que zero.     * Se for, ele retira os dados e decrementa count.     * Caso contrário, o processo vai dormir.   * Sempre testam para verificar se o outro processo está acordado, acordando-o se for o caso.  \\--- PÁGINA 8 \\---  ## **Sleep e WakeUp**  \\[Imagem: Pseudocódigo para Produtor/Consumidor com Sleep/Wakeup\\]   O slide mostra um pseudocódigo para o produtor e o consumidor. O producer verifica se count \\== N e chama sleep() se estiver cheio. Após inserir, ele verifica se count \\== 1 e chama wakeup(consumer). O consumer verifica se count \\== 0 e chama sleep() se estiver vazio. Após remover, ele verifica se count \\== N-1 e chama wakeup(producer).   \\--- PÁGINA 9 \\---  ## **Sleep e WakeUp**  Situação-Problema relacionada à preempção:   O pseudocódigo da página 8 é mostrado novamente, com uma seta apontando para a linha if(count \\== 0\\) no consumidor e outra apontando para a linha if(count \\== 1\\) no produtor. Isso ilustra um cenário de condição de corrida: o consumidor vê count como 0, mas é interrompido antes de chamar sleep(). O produtor executa, incrementa count para 1, envia um wakeup(consumer) (que é perdido, pois o consumidor ainda não está dormindo) e continua. Quando o consumidor volta, ele executa sleep() e nunca mais é acordado, levando a um deadlock.   \\--- PÁGINA 10 \\---  ## **Sleep e WakeUp**  * **Problema relacionado à preempção:**     * Interrupção no consumidor após a comparação count==0.     * A essência do problema está no fato de, por não estar dormindo, o consumidor perdeu o sinal de wakeup.     * Ambos os processos dormem para sempre.  \\--- PÁGINA 11 \\---  ## **Sleep e WakeUp**  * **Solução \\- bit de wakeup:**     * bit de controle recebe um valor true quando um sinal é enviado para um processo que não está dormindo.     * Quando o processo é posto para dormir, o bit é verificado.     * No entanto, no caso de vários pares de processos, vários bits devem ser criados sobrecarregando o sistema.  \\--- PÁGINA 12 \\---  ## **Sleep e WakeUp**  * **\\\"bit de wakeup\\\"**:     * Quando um wakeup é mandado à um processo já acordado, este bit é setado.     * Depois, quando o processo tenta ir dormir, se o bit de espera de wakeup estiver ligado, este bit será desligado, e o processo será mantido acordado.  \\--- PÁGINA 13 \\---  ## **Seção crítica: Propostas de Solução**  *Este slide repete a lista de Propostas de Solução, destacando \\\"Semáforos\\\".*  \\--- PÁGINA 14 \\---  ## **Semáforos**  * É uma variável utilizada para controlar o acesso a recursos compartilhados;   * Tem o objetivo de sincronizar o uso de recursos em grande quantidade;   * Nasceu como proposta para contar o número de wake-ups armazenados para uso futuro.  \\--- PÁGINA 15 \\---  ## **Semáforos**  \\[Imagem: Ilustração de Semáforos\\]   Duas imagens ilustram o conceito. A primeira mostra uma fila de pessoas (processos) sendo controlada por seguranças (semáforos) antes de entrar em uma área. A segunda mostra um guichê com contadores readers: 0, waitToRead: 3, writers: 1, representando um semáforo que controla o acesso de leitores e escritores.  * Pode ser do tipo geral ou de contagem (counting) ou binário (mutex / booleano);   * Pode ser implementado através de espera ocupada ou através da associação de uma fila a cada semáforo.  \\--- PÁGINA 16 \\---  ## **Semáforos**  \\[Imagem: Semáforo controlando acesso a uma impressora\\]   Um diagrama mostra TASK 1 e TASK 2 tentando acessar um recurso PRINTER. Ambas devem primeiro adquirir um SEMAPHORE (representado por uma chave). Apenas a tarefa que consegue o semáforo pode acessar a impressora.   \\--- PÁGINA 17 \\---  ## **Semáforos**  * **Semáforo \\= 0**:     * Não há recurso livre.     * Nenhum wakeup está armazenado.   * **Semáforo \\> 0**:     * Recurso livre.     * Um ou mais wakeups estão pendentes \\>\\> Devem utilizar os recursos.   * Dijkstra propôs 2 operações sobre semáforos, que são generalizações de sleep e wakeup.  \\--- PÁGINA 18 \\---  ## **Semáforos**  * **Operações sobre semáforos (atômicas):**     * **down** \\- executada sempre que um processo deseja usar um recurso compartilhado:       * Verifica se o valor do semáforo é maior que 0;       * Se for, semáforo=semáforo \\- 1, e continua a operação;       * Se não for, o processo que executou o down fica bloqueado.     * **up** \\- executada sempre que um processo liberar o recurso.       * semáforo=semáforo+1;       * Se há processos bloqueados nesse semáforo, escolhe um deles e o desbloqueia.  \\--- PÁGINA 19 \\---  ## **Semáforos: Operações atômicas**  * Uma vez que uma operação semáforo iniciou, nenhum outro processo pode acessar o semáforo até que a operação seja completada ou bloqueada;   * Geralmente implementadas como chamada de sistema (syscall);   * O S.O. desabilita todas as interrupções enquanto está testando o semáforo;   * Se houver múltiplas CPUs, cada semáforo é protegido por uma variável Lock, como a instrução TSL.  \\--- PÁGINA 20 \\---  ## **Semáforos**  * **Semáforo geral (counting semaphore)** \\- usados para controlar acessos a um determinado recurso com um número finito de instâncias.   * Semáforos usados para implementar exclusão mútua são chamados de **mutex** (mutual exclusion semaphore) ou binários ou booleanos, por apenas assumirem os valores 0 e 1\\.   * Primitivas de chamadas de sistema: down (sleep) e up (wakeup).   * Originalmente, em holandês, P (down \\- proberen \\- testar) e V (up \\- verhogen \\- incrementar).  \\--- PÁGINA 21 \\---  ## **Semáforo Geral**  * Inicializa com o número de recursos disponíveis;   * Cada processo que deseja utilizar um recurso executa um down();   * Quando um processo libera um recurso, executa um up();   * Quando o contador do semáforo vale 0, todos os recursos estão sendo usados e o processo é posto para dormir.  \\--- PÁGINA 22 \\---  ## **Semáforo Binário**  * Serve para conceder entrada à região crítica;   * **Mutex** é uma variável com apenas dois estados: bloqueada (0) e desbloqueada (1);   * Quando uma thread ou processo precisa acessar uma região crítica, chama mutex\\_lock;   * Quando termina, chama mutex\\_unlock.  \\--- PÁGINA 23 \\---  ## **Semáforos**  * **Problema produtor/consumidor:** Resolve o problema de perda de sinais enviados.   * Solução utiliza três semáforos:     * Full: conta o número de slots no buffer que estão ocupados; iniciado com 0\\.     * Empty: conta o número de slots no buffer que estão vazios; iniciado com o número total de slots no buffer.     * Mutex: garante que os processos produtor e consumidor não acessem o buffer ao mesmo tempo; iniciado com 1\\.  \\--- PÁGINA 24 \\---  ## **Semáforos**  \\[Imagem: Código do Produtor/Consumidor com Semáforos\\]   O slide mostra o código para o produtor e consumidor usando as três variáveis de semáforo (mutex, empty, full) e as operações down e up para garantir a sincronização e a exclusão mútua corretamente.   \\--- PÁGINA 25 \\---  ## **Semáforos**  * **Quando utilizar um mutex?**     * É um mecanismo de trava para garantir o acesso a um recurso compartilhado. Somente uma tarefa pode manter a trava e liberá-la.   * **Quando utilizar um semáforo binário?**     * É similar ao mutex, mas é um mecanismo de sinalização.   * **Quando utilizar um semáforo?**     * Pode gerenciar mais de um dispositivo do mesmo tipo;     * Pode ser utilizado como uma fila (compartilhamento de recursos).  \\--- PÁGINA 26 \\---  ## **Mutex vs. Semáforos**  *O slide mostra a estrutura de uso de um Mutex (wait(mutex); Critical Section; signal(mutex);) e a implementação das operações wait(S) e signal(S) para um semáforo.*  \\--- PÁGINA 27 \\---  ## **Seção crítica: Propostas de Solução**  *Este slide repete a lista de Propostas de Solução, destacando \\\"Monitores\\\".*  \\--- PÁGINA 28 \\---  ## **Monitores**  * Idealizado por Hoare (1974) e Brinch Hansen (1975).   * Primitiva de alto nível para sincronizar processos, conjunto de procedimentos, variáveis e estruturas de dados agrupados em um único módulo ou pacote;   * **Somente um processo pode estar ativo no monitor ao mesmo tempo;**   * Não são boas soluções para sistemas distribuídos.   * Todos os recursos compartilhados devem estar implementados dentro do Monitor;   * Depende da linguagem de programação e o compilador é quem garante a exclusão mútua;   * Existente em Java. Não existe em C.  \\--- PÁGINA 29 \\---  ## **Monitores**  * Um **tipo de dado abstrato** ou ADT (abstract data type) encapsula dados com um conjunto de funções para operarem sobre esses dados.   * Um **tipo monitor** é um ADT que inclui um conjunto de operações definidas pelo programador e que são dotadas de exclusão mútua dentro do monitor.  \\--- PÁGINA 30 \\---  ## **Monitores: Execução**  * Chamada a uma rotina do monitor;   * Teste para detectar se um outro processo está ativo dentro do monitor;   * Se positivo, o processo novo ficará bloqueado até que o outro processo deixe o monitor;   * Caso contrário, o processo novo executa as rotinas no monitor.   * Pode utilizar variáveis de condição para suspender e reassumir processos:     * x.wait() \\- o processo que invoca a operação é suspenso.     * x.signal() \\- retoma um dos processos que invocou x.wait().  \\--- PÁGINA 31 \\---  ## **Monitores: Esquemático/Estrutura**  \\[Imagem: Estrutura de um Monitor\\]   Um diagrama mostra a estrutura de um monitor. É uma caixa que encapsula shared data, operations, e initialization code. Processos que querem executar as operações entram em uma entry queue. Apenas um processo pode estar executando dentro do monitor por vez.   \\--- PÁGINA 32 \\---  ## **Monitores**  * Se vários processos estão suspensos na condição x, e uma operação x.signal() é executada por algum processo, como determinar qual dos processos suspensos deve ser retomado em seguida?   * Uma solução simples é usar uma ordem \\\"primeiro a entrar, primeiro a ser atendido\\\" (FCFS).   * Em muitas circunstâncias, no entanto, um esquema de scheduling tão simples não é adequado.  \\--- PÁGINA 33 \\---  ## **Monitores**  * Infelizmente, o conceito de monitor não garante que a sequência de acesso anterior seja seguida. Especificamente, os seguintes problemas podem ocorrer:     * Um processo pode acessar um recurso sem antes obter permissão.     * Um processo pode nunca liberar um recurso.     * Um processo pode tentar liberar um recurso que nunca solicitou.     * Um processo pode solicitar o mesmo recurso duas vezes.  \\--- PÁGINA 34 \\---  ## **Semáforos e Monitores: Limitações**  * Ambos são boas soluções somente para CPUs com memória compartilhada. Não são boas soluções para sistema distribuídos;   * Nenhuma das soluções provê troca de informações entre processo que estão em diferentes máquinas;   * Monitores dependem de uma linguagem de programação — poucas linguagens suportam Monitores.  \\--- PÁGINA 35 \\---   Este slide repete a lista de Propostas de Solução da página 27\\.   \\--- PÁGINA 36 \\---  ## **Memória Transacional**  * O conceito de memória transacional teve origem na teoria de bancos de dados e fornece uma estratégia para a sincronização de processos.   * Uma transação de memória é uma sequência de operações atômicas de leitura-gravação em memória.   * Se todas as operações de uma transação são concluídas, a transação de memória é **confirmada**. Caso contrário, as operações devem ser **abortadas** e revertidas.   * Os benefícios da memória transacional podem ser obtidos por recursos adicionados a uma linguagem de programação.  \\--- PÁGINA 37 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 2\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulos 5 e 6\\.  \\--- PÁGINA 38 \\---   Slide final com o logo da universidade e contato do professor.