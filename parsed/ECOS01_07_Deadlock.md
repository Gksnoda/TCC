\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Deadlock**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Impasse ou Deadlock**  \\[Imagem: Caricatura do Jantar dos Filósofos\\]   Uma famosa caricatura da Communications of the ACM mostrando cinco monges (filósofos) em uma mesa redonda. Quatro estão em deadlock, cada um segurando um hashi (garfo) e esperando pelo hashi do vizinho, sem conseguir comer. O quinto, ao centro, come tranquilamente.   \\--- PÁGINA 3 \\---  ## **Impasse ou Deadlock**  Ocorrem em virtude do compartilhamento de recursos escassos.  \\[Imagem: Cruzamento de trânsito em deadlock\\]   Uma foto aérea de um cruzamento completamente travado, com carros e ônibus bloqueando uns aos outros em todas as direções, ilustrando um deadlock na vida real.   \\--- PÁGINA 4 \\---  ## **Impasse ou Deadlock**  * Ocorrem em virtude do compartilhamento de recursos escassos.   * Sistemas Operacionais devem fornecer acesso aos recursos.   * Podem ocorrer tanto em recursos de hardware (ex.: HD) quanto de software (ex.: Banco de Dados).   * Deadlocks ocorrem quando processos obtêm acesso exclusivo a recursos, que podem ser:     * Preemptivos (p.ex.: memória, CPU com escalonador, etc);     * Não-preemptivos (p.ex.: impressora).   * Geralmente ocorrem com recursos não preemptivos.  \\--- PÁGINA 5 \\---  ## **Impasse ou Deadlock**  Eventos para o uso de recursos (pode ser feito por mutexes):  1. Requisição;   2. Utilização;   3. Liberação.   * Se o recurso requerido não está disponível:     * Processo fica bloqueado até a liberação do recurso;     * Processo que requisitou o recurso falha, gerando uma mensagem de erro. Após um intervalo de tempo tenta novamente.  \\--- PÁGINA 6 \\---  ## **Impasse ou Deadlock**  Processos estão em deadlock se cada processo estiver esperando por um evento que somente outro processo no conjunto pode causar.  \\[Imagem: Diagrama de Deadlock\\]   Um diagrama cíclico mostrando o Process 1 que foi alocado (Assigned to) o Resource 1 e está esperando (Waiting for) o Resource 2\\. O Process 2 foi alocado o Resource 2 e está esperando o Resource 1\\. Isso cria um estado de Deadlock.   \\--- PÁGINA 7 \\---  ## **Impasse ou Deadlock**  São exemplos de estratégias para prevenir deadlock:  * Uso de ordenação por precedência dos recursos (os recursos devem ser alocados seguindo uma ordem);   * Determinação de tempo de alocação;   * Determinação que nenhum processo terá acesso exclusivo aos recursos; e   * Pré-alocação de todos os recursos no início da execução do programa.  \\--- PÁGINA 8 \\---  ## **Impasse ou Deadlock: Condições necessárias**  * **Exclusão mútua:** um recurso só pode estar alocado para um processo em um determinado momento.   * **Posse durante a espera (hold and wait):** processos que já possuem algum recurso podem requerer outros.   * **Inexistência de preempção:** recursos já alocados não podem ser retirados; somente o próprio processo pode liberá-los.   * **Espera circular:** um processo espera por recursos alocados a outro processo, em uma cadeia circular.  \\--- PÁGINA 9 \\---  ## **Impasse ou Deadlock**  * **Posse durante a espera (hold and wait):** processos que já possuem algum recurso podem requerer outros.  \\[Imagem: Exemplo de Posse e Espera\\]   Um diagrama mostrando que Task 1 possui (holds) a impressora (printer) e quer (wants) o scanner. Ao mesmo tempo, Task 2 possui o scanner e quer a impressora.   \\--- PÁGINA 10 \\---  ## **Impasse ou Deadlock**  * O processo 1 espera pelo processo 2, que espera pelo processo 3, que espera pelo processo 4, que espera pelo processo 1\\.   * Geralmente, deadlocks são representados por grafos dirigidos, a fim de facilitar sua detecção, prevenção e recuperação.  \\[Imagem: Exemplo de Espera Circular\\]   Um diagrama mostrando uma cadeia: Processo 1 tem o Recurso 1 e espera pelo Recurso 2, que está com o Processo 2, que espera pelo Recurso 3... até o Processo 4 que espera pelo Recurso 1, fechando o ciclo.   \\--- PÁGINA 11 \\---  ## **Modelo do sistema: Grafo de alocação de recursos**  * Recursos têm vários tipos R₁, R₂, ..., Rₘ   * Cada recurso Rᵢ tem Wᵢ instâncias   * Processos acessam recursos da mesma forma:     * Solicitação\\* → Uso → Liberação     * \\* se não puder ser atendida imediatamente, espera   * Solicitação e Liberação são chamadas de sistema  \\--- PÁGINA 12 \\---  ## **Modelo do sistema: Grafo de alocação de recursos**  * Permite descrever com mais precisão deadlocks   * Vértices são divididos em dois tipos:     * P \\= {P₁, P₂, ..., Pn}, os processos no sistema     * R \\= {R₁, R₂, ..., Rm}, os recursos do sistema   * Arestas são também são de dois tipos:     * **Solicitação:** aresta direcionada Pi → Rj     * **Atribuição:** aresta direcionada Ri → Pj  \\--- PÁGINA 13 \\---  ## **Modelo do sistema: Grafo de alocação de recursos**  * Um processo: Pᵢ (círculo)   * Tipo de recurso com 4 instâncias: Rj (quadrado com 4 pontos dentro)   * Pᵢ requisita instância de Rj: Pᵢ → Rj   * Pᵢ detém uma instância de Rj: Rj → Pᵢ  \\--- PÁGINA 14 \\---  ## **Modelo do sistema: Grafo de alocação de recursos**  * Se não há ciclos no grafo → não há deadlock   * Se o grafo contém ciclos, depende:     * Se recursos só têm uma instância → há deadlock     * Se há mais de uma instância → possível deadlock  \\--- PÁGINA 15 \\---  ## **Impasse ou Deadlock: Grafo de alocação de recursos**  \\[Imagem: Exemplos de Grafos de Alocação de Recursos\\]   (a) Recurso R alocado ao Processo A. (b) Processo B requisita o Recurso S. (c) Um ciclo de deadlock formado: Processo C tem o recurso U e quer T; D tem T e quer S; U tem S e quer... Este exemplo parece ter uma pequena inconsistência, mas ilustra a formação de um ciclo.   \\--- PÁGINA 16 \\---   \\[Imagem: Mais Grafos de Alocação de Recursos\\]   Dois grafos de alocação de recursos. O da esquerda não tem ciclo. O da direita tem um ciclo envolvendo P1, P2, R1 e R2, indicando um deadlock.   \\--- PÁGINA 17 \\---  ## **Impasse (Deadlock): Algoritmo de detecção**  * Considerações a serem feitas:     * Quão frequentes são os deadlocks?     * Quantos processos são afetados?   * **Detecção frequente:**     * Pouco tempo de espera     * Pouca chance de \\\"propagação do travamento\\\"   * **Detecção esporádica:**     * Menor overhead de detecção     * Pode encontrar muitos ciclos  \\--- PÁGINA 18 \\---  ## **Impasse (Deadlock): Recuperação**  * É preciso quebrar os ciclos no grafo:     * **Abortando um ou mais processos**       * Processo termina com erro       * Estado do sistema pode ficar inconsistente     * **Realizando a preempção de recursos**       * Processos que sofrem preempção precisam \\\"retroceder\\\" (roll-back) para um ponto anterior   * Considerações:     * Como escolher o(s) processo(s) vítima(s)?     * Como distribuir os recursos reclamados?     * Como evitar a inanição?  \\--- PÁGINA 19 \\---  ## **Impasse (Deadlock): Estratégias para prevenção e/ou tratamento**  1. Ignorar o problema.   2. Detectar e recuperar o problema.   3. Evitar dinamicamente o problema \\- alocação cuidadosa de recursos.   4. Prevenir o problema por meio da não-satisfação de uma das quatro condições necessárias.  \\--- PÁGINA 20 \\---  ## **Impasse (Deadlock): Estratégias**  ### **1\\) Ignorar o problema.**  * Utilizado se a frequência de ocorrência de deadlocks com relação a outras falhas do sistema não é tão expressiva.   * Ignorar se o esforço em solucionar o problema for muito grande em relação à sua frequência.   * Usado na maioria dos sistemas, inclusive Unix e Windows. Alto custo de tratamento e baixa frequência de ocorrência.  \\--- PÁGINA 21 \\---  ## **Impasse (Deadlock): Estratégias**  ### **2\\) Detectar e recuperar o problema:**  * Permite que os deadlocks ocorram. Tenta detectar as causas e solucionar a situação.   * Algoritmos:     * Detecção com um recurso de cada tipo;     * Detecção com vários recursos de cada tipo:       * Recuperação por meio de preempção;       * Recuperação por meio de rollback;       * Recuperação por meio de eliminação de processos.  \\--- PÁGINA 22 \\---  ## **Impasse (Deadlock): Estratégias**  ### **2\\) Detectar e recuperar o problema: Detecção com um recurso de cada tipo**  \\[Imagem: Grafo de alocação de recursos com vários processos e recursos\\]   Um grafo complexo com múltiplos processos (círculos) e recursos (quadrados) e as setas indicando alocações e requisições.   \\--- PÁGINA 23 \\---  ## **Impasse (Deadlock): Estratégias**  ### **2\\) Detectar e recuperar o problema: Detecção com um recurso de cada tipo**  * Se todos os recursos têm apenas uma única instância, então podemos definir um algoritmo de detecção de deadlocks que use uma variante do grafo de alocação de recursos, chamado **grafo de espera (wait-for)**.   * Existe um deadlock no sistema se e somente se o grafo de espera contiver um ciclo.  \\--- PÁGINA 24 \\---  ## **Impasse (Deadlock): Estratégias**  \\[Imagem: Grafo de alocação e grafo de espera\\]   (a) Um grafo de alocação de recursos. (b) O grafo de espera correspondente, mostrando apenas os processos e as dependências entre eles. Um ciclo D → E → G → D é visível, indicando deadlock.   \\--- PÁGINA 25 \\---  ## **Impasse (Deadlock): Estratégias**  ### **2\\) Detectar e recuperar o problema: Detecção com um recurso de cada tipo**  * Há a possibilidade de deadlock?  \\[Imagem: Estados Seguros vs. Inseguros\\]   Um diagrama mostrando que o conjunto de todos os estados do sistema é dividido em estados safe (seguros) e unsafe (inseguros). Dentro da região insegura, existe uma sub-região que é o estado de deadlock. Um sistema pode estar em um estado inseguro sem estar em deadlock, mas um deadlock é sempre um estado inseguro.   \\--- PÁGINA 26 \\---  ## **Impasse (Deadlock): Estratégias**  ### **2\\) Detectar e recuperar o problema: Detecção com vários recursos de cada tipo**  * n processos: P1 a Pn   * M classes diferentes de recursos   * Usamos um vetor de recursos existentes \\- **E**   * Vetor de recursos disponíveis \\- **A**   * Duas matrizes:     * **C** \\- matriz de alocação corrente     * **R** \\- matriz de requisições  \\--- PÁGINA 27 \\---   Este slide repete a descrição das estruturas de dados (vetores e matrizes) para o algoritmo de detecção com múltiplos recursos.   \\--- PÁGINA 28 \\---  ## **Impasse (Deadlock): Estratégias**  \\[Imagem: Matrizes para detecção de deadlock\\]   O slide apresenta as matrizes C (alocação corrente) e R (requisições) e os vetores E (existentes) e A (disponíveis) para um exemplo.   \\--- PÁGINAS 29 a 38 \\---  ## **Impasse (Deadlock): Estratégias**  *Estes slides percorrem passo a passo a execução do algoritmo de detecção de deadlock para o exemplo apresentado na página 28, verificando se existe uma sequência de execução que permita que todos os processos terminem. No exemplo, a sequência P3, P2, P1 é encontrada, provando que o sistema não está em deadlock.*  \\--- PÁGINA 39 \\---  ## **Impasse (Deadlock): Estratégias**  * Deve-se saber de antemão que recursos serão requisitados.   * Processos podem ser abortados e os recursos requisitados não serão utilizados.   * É um cenário desafiador.   * **Quando devemos invocar o algoritmo de detecção?** A resposta depende da frequência com que um deadlock pode ocorrer e de quantos processos serão afetados.  \\--- PÁGINA 40 \\---  ## **Impasse (Deadlock): Estratégias**  * **Quando devemos procurar por deadlocks?**     * a) Toda vez que uma requisição é realizada?     * b) A cada k minutos?     * c) Quando a utilização da CPU cai abaixo de um valor durante um certo período de tempo?  \\--- PÁGINA 41 \\---  ## **Impasse (Deadlock): Estratégias**  * **Recuperação por meio de preempção:**     * Retirar temporariamente um recurso de um processo e entregá-lo a outro.     * Depende da natureza do recurso.     * Frequentemente muito difícil \\- gera prejuízos.  \\--- PÁGINA 42 \\---  ## **Impasse (Deadlock): Estratégias**  * **Recuperação por meio de Rollback:**     * O estado de cada processo e o uso de recursos é armazenado em um arquivo de verificação, chamado de **checkpoint file**.     * Quando ocorre um deadlock, o processo volta ao ponto em que estava antes de adquirir o recurso, utilizando o checkpoint file apropriado. Todo trabalho feito após esse ponto é perdido.  \\--- PÁGINA 43 \\---  ## **Impasse (Deadlock): Estratégias**  * **Recuperação por eliminação do processo:**     * Um ou mais processos que estão no ciclo com deadlock são interrompidos.     * Não garante a eliminação de deadlock. Pode ser necessária a continuação da atividade até quebrar o ciclo.     * Melhor solução para processos que não causam muito prejuízo (Ex: Compilação).  \\--- PÁGINA 44 \\---  ## **Impasse (Deadlock): Estratégias**  ### **3\\) Evitar dinamicamente o problema:**  * Alocação de recursos na medida em que se fazem necessários (runtime).   * Escalonamento cuidadoso \\- alto custo.   * Prévio conhecimento dos recursos que serão utilizados.   * **Algoritmo do Banqueiro:**     * Para um único tipo de recurso.     * Para vários tipos de recursos.   * Utilizam a noção de **Estados Seguros** e **Inseguros**.  \\--- PÁGINA 45 \\---  ## **Impasse (Deadlock): Estratégias**  ### **3\\) Evitar dinamicamente o problema:**  * **Estados Seguros:** não provocam deadlocks. Há uma maneira de atender a todas as requisições.   * **Estados Inseguros:** podem provocar deadlocks. Não necessariamente provocam/ocorrem deadlocks.  \\--- PÁGINAS 46 a 50 \\---  ## **Impasse (Deadlock): Estratégias**  *Estes slides detalham o conceito de estado seguro e inseguro com um exemplo de 12 acionadores de fita e 3 processos, mostrando como uma alocação pode levar de um estado seguro para um inseguro.*  \\--- PÁGINA 51 \\---  ## **Impasse (Deadlock): Estratégias**  * **Mecanismos (Algoritmo do Banqueiro):**     * Utiliza as mesmas estruturas de detecção com vários recursos (E, A, C, R).     * **Estado Seguro:** Aquele no qual existe alguma ordem em que todo processo vai terminar, ainda que todos solicitem seu número máximo de recursos.  \\--- PÁGINAS 52 a 63 \\---  ## **Impasse (Deadlock): Estratégias**  *Estes slides apresentam um exemplo detalhado do Algoritmo do Banqueiro com um único tipo de recurso, mostrando como o \\\"banqueiro\\\" (SO) verifica se uma requisição de recurso levará a um estado inseguro antes de concedê-la.*  \\--- PÁGINA 64 \\---  ## **Impasse (Deadlock): Estratégias**  ### **Algoritmo do Banqueiro:**  * Idealizado por Dijkstra (1965);   * Algoritmo de escalonamento para evitar deadlock;   * O Sistema Operacional funciona como um banqueiro \\- Verifica se um pedido leva a um estado inseguro. Em caso positivo, o pedido é negado.  \\--- PÁGINAS 65 a 70 \\---  ## **Impasse (Deadlock): Estratégias**  *Estes slides estendem o exemplo do Algoritmo do Banqueiro para múltiplos tipos de recursos, usando matrizes de alocação e necessidade para determinar se um estado é seguro.*  \\--- PÁGINA 71 \\---  ## **Impasse (Deadlock): Estratégias**  ### **Algoritmo do Banqueiro: Desvantagens**  * Pouco utilizado, pois é difícil saber quais recursos serão necessários.   * O escalonamento cuidadoso é muito caro para o sistema.   * O número de processos é dinâmico e pode variar constantemente.  ### **Vantagem:**  * Na teoria, o algoritmo é ótimo.  \\--- PÁGINA 72 \\---  ## **Impasse (Deadlock): Estratégias**  ### **4\\) Prevenção:**  * **Exclusão mútua:** alocar recursos utilizando spooling.   * **Posse durante a espera:** processos requisitam todos os recursos que precisam antes da execução.   * **Inexistência de preempção:** retirada de recursos dos processos \\- praticamente não implementável.   * **Espera circular:** ordenar numericamente os recursos e realizar a solicitação em ordem.  \\--- PÁGINAS 73 a 79 \\---  ## **Impasse (Deadlock): Estratégias**  *Estes slides detalham como a prevenção de deadlock funciona ao negar cada uma das quatro condições necessárias (Exclusão Mútua, Posse e Espera, Sem Preempção e Espera Circular).*  \\--- PÁGINAS 80 a 83 \\---  ## **Impasse (Deadlock): Estratégias**  *Estes slides revisam as estratégias de recuperação de deadlock, como abortar processos ou realizar a preempção de recursos, e discutem os fatores a serem considerados ao escolher uma \\\"vítima\\\".*  \\--- PÁGINAS 84 a 87 \\---  ## **Exercícios de fixação**  *Estas páginas contêm exercícios sobre o Algoritmo do Banqueiro e detecção de deadlock para os alunos praticarem.*  \\--- PÁGINA 88 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 6\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 7\\.  \\--- PÁGINA 89 \\---   Slide final com o logo da universidade e contato do professor.