\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Escalonamento**  ### **Parte 2**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Algoritmos de escalonamento**  * Sistemas Batch   * Sistemas Interativos   * Sistemas Tempo Real  \\--- PÁGINA 3 \\---  ## **Algoritmo de escalonamento: Sistemas Interativos**  \\--- PÁGINA 4 \\---  ## **Algoritmo de Escalonamento: Interativos**  * Possuem o objetivo de tempo de resposta, resposta rápida às requisições; proporcionalidade (time-sharing); satisfazer as expectativas dos usuários.     1. Round-Robin     2. Prioridade (Múltiplas filas)     3. Múltiplas filas com realimentação     4. SPN (Shortest Process Next)     5. Garantido     6. Loteria     7. Fair-Share  \\--- PÁGINA 5 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * Antigo, mais simples e mais utilizado;   * Preemptivo;   * Cada processo recebe um tempo de execução chamado **time-slice** ou **quantum**. Ao final desse tempo o processo é suspenso e outro processo é colocado em execução. Também é suspenso em caso de interrupção;   * Troca de contexto frequente (quantum);   * Escalonador mantém uma fila de processos prontos.  \\--- PÁGINA 6 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  \\[Imagem: Filas no escalonamento Round-Robin\\]   Diagrama semelhante ao do FCFS, mas com uma seta adicional saindo do estado Running de volta para a Ready queue, com a anotação preempted. Isso indica que um processo pode ser interrompido ao fim do seu quantum e voltar para a fila de prontos.   \\--- PÁGINA 7 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * Os processos são colocados em uma fila circular (de prontos) e executados um a um;   * Quando seu tempo acaba, o processo é suspenso e volta para o final da fila. Outro processo (primeiro da fila) é então colocado em execução;   * Quando o processo solicita E/S, vai para a fila de bloqueados e, ao terminar a operação, volta para o final da fila de prontos.  \\--- PÁGINA 8 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  \\[Imagem: Gráfico de Gantt para Round-Robin\\]   Um gráfico de Gantt para 4 processos com um quantum de 3\\. A execução é: P0(3), P1(3), P2(3), P3(3), P0(2, restante), P2(3), P3(3), P2(2, restante). A tabela mostra os tempos de chegada e de execução.   \\--- PÁGINA 9 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  *O slide mostra novamente o gráfico e a tabela da página 8, agora com o cálculo detalhado do tempo de espera para cada processo e o tempo médio de espera, que resulta em 8,5.*  \\--- PÁGINA 10 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Problema:** tempo de chaveamento de processos (troca de contexto).   * O desempenho do algoritmo RR depende substancialmente do tamanho do quantum de tempo.     * Por um lado, se o quantum de tempo é extremamente longo, a política RR é igual à política FCFS.     * Por outro lado, quando o quantum de tempo é extremamente curto (digamos, 1 milissegundo), a abordagem RR pode resultar em um grande número de mudanças de contexto.  \\--- PÁGINA 11 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  \\[Imagem: Impacto do tamanho do quantum\\]   \\*Três barras ilustram o impacto do tamanho do quantum para um processo que precisa de 10 unidades de tempo.  * Com quantum 12 (maior que o necessário), há 0 trocas de contexto.   * Com quantum 6, há 1 troca de contexto.   * Com quantum 1, há 9 trocas de contexto.     Conclusão: Dilema: quantum \\- pequeno ou grande?\\*  \\--- PÁGINA 12 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Quantum:**     * 1ª abordagem: t=4ms (quantum) e troca de contexto=1ms       * 25% do tempo de CPU é consumido na troca de processos.       * Menor eficiência  \\--- PÁGINA 13 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Quantum:**     * ...     * 2ª abordagem: t=100ms (quantum) e troca de contexto=1ms       * 1% do tempo de CPU é consumido na troca de processos.  \\--- PÁGINA 14 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Quantum:**     * ...     * Valor razoável: t \\= 20-50ms (quantum)  \\--- PÁGINA 15 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * O tempo de turnaround também depende do tamanho do quantum de tempo.   * O tempo médio de turnaround de um conjunto de processos não melhora necessariamente na medida em que o tamanho do quantum de tempo aumenta.   * Geralmente, o tempo médio de turnaround pode ser melhorado quando a maioria dos processos termina seu próximo pico de CPU em um único quantum de tempo.  \\--- PÁGINA 16 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Turnaround – Exemplo:**     * Dados três processos de 10 unidades de tempo cada e um quantum de 1 unidade de tempo, o tempo médio de turnaround é de 29\\.  \\--- PÁGINA 17 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Turnaround – Exemplo:**     * ...     * Se o quantum de tempo é igual a 10, no entanto, o tempo médio de turnaround cai para 20\\.  \\--- PÁGINA 18 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * **Turnaround – Exemplo:**     * ...     * Se o tempo de mudança de contexto for incluído, o tempo médio de turnaround aumenta ainda mais para um quantum de tempo menor, já que mais mudanças de contexto são necessárias.  \\--- PÁGINA 19 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **1\\. Round-Robin**  * Embora o quantum de tempo deva ser longo, comparado ao tempo de mudança de contexto, ele não deve ser longo demais.   * Como apontado anteriormente, se o quantum de tempo for longo demais, o scheduling RR degenerará para uma política FCFS.   * Uma regra prática é a de que 80% dos picos de CPU devem ser menores do que o quantum de tempo.  \\--- PÁGINA 20 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **2\\. Prioridade (Múltiplas filas)**  * Preemptivo;   * Cada processo possui uma prioridade;   * Os processos prontos com maior prioridade são executados primeiro;   * Prioridades são atribuídas dinamicamente (pelo sistema) ou estatisticamente;   * Round-Robin pressupõe igual prioridade para todos os processos.  \\--- PÁGINA 21 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **2\\. Prioridade (Múltiplas filas)**  \\[Imagem: Filas de Múltiplas Prioridades\\]   Um diagrama mostrando várias filas horizontais, cada uma para uma classe de prioridade (Real-time, System, Interactive, Batch). Processos de maior prioridade são executados primeiro. Dentro de cada fila, o escalonamento pode ser Round-Robin. Um processo de uma fila de menor prioridade só executa se todas as filas acima estiverem vazias.   \\--- PÁGINA 22 \\---   Este slide repete a imagem do top para ilustrar processos com diferentes prioridades.   \\--- PÁGINA 23 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **2\\. Prioridade (Múltiplas filas)**  \\[Imagem: Exemplo de Filas de Prioridade\\]   Um diagrama com cinco filas de prioridade, da mais alta para a mais baixa: system processes, interactive processes, interactive editing processes, batch processes, student processes.   \\--- PÁGINA 24 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **2\\. Prioridade (Múltiplas filas)**  * Enquanto houver processos na classe (fila) de maior prioridade, rode cada um de seus processos usando Round-Robin;   * Se essa classe não tiver mais processos: passe para a próxima de menor prioridade;   * É necessário realizar o ajuste das prioridades de alguma forma. Do contrário, os processos nas filas menos prioritárias podem nunca ser executados (inanição).  \\--- PÁGINA 25 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **3\\. Múltiplas filas com realimentação**  * Preemptivo;   * Cada vez que um processo é executado e suspenso, ele recebe mais tempo para execução;   * Inicialmente recebe 1 quantum e é suspenso; então muda de classe e recebe 2, sendo suspenso; e, assim, ocorre sucessivamente.   * Reduz o número de trocas de processo:     * Os processos mais curtos terminam logo.     * Aos mais longos é dado mais tempo, progressivamente.  \\--- PÁGINA 26 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **3\\. Múltiplas filas com realimentação**  \\[Imagem: Filas com Realimentação\\]   Um diagrama mostrando três filas. Um processo entra na primeira fila (quantum=8). Se não terminar, ele vai para a segunda fila (quantum=16). Se ainda não terminar, vai para uma terceira fila, que utiliza FCFS.   \\--- PÁGINA 27 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **3\\. Múltiplas filas com realimentação**  * **Exemplo:**     * Um processo precisa de 100 quanta para ser executado;     * As filas disponíveis possuem quantum nos valores: 1, 2, 4, 8, 16, 32, 64, ...  \\--- PÁGINA 28 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **3\\. Múltiplas filas com realimentação**  * **Exemplo:**     * Um processo precisa de 100 quanta para ser executado;     * Inicialmente, ele recebe um quantum para execução;     * Das próximas vezes ele receberá, respectivamente, 2, 4, 8, 16, 32 e 64 quanta (7 chaveamentos) para execução;     * Quanto mais próximo de ser finalizado, menos frequente é o processo na CPU; mais ele desce na fila de prioridade.  \\--- PÁGINA 29 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **3\\. Múltiplas filas com realimentação**  \\[Imagem: Movimentação entre Filas com Realimentação\\]   Diagrama mostrando um processo sendo rebaixado de uma fila de maior prioridade com Shorter quantum para uma de menor prioridade com Longer quantum após ser preemptado.   \\--- PÁGINA 30 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **4\\. SPN (Shortest Process Next)**  * É a versão do algoritmo Shortest Job First para sistemas interativos;   * Em processos interativos não se conhece o tempo necessário para a execução.   * **Como empregar este algoritmo?**     * Estimativa de tempo com base em execuções antigas da mesma tarefa.     * Verificação do comportamento passado do processo e estimação do tempo.  \\--- PÁGINA 31 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **5\\. Garantido**  * Garantias são dadas aos processos dos usuários:     * Com n usuários (ou processos em sistemas monousuário), 1/n do tempo de CPU é reservado para cada usuário.  \\--- PÁGINA 32 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **6\\. Loteria**  * Cada processo recebe \\\"bilhetes\\\" que lhe dão direito a recursos do sistema (inclusive processador), com fatia de processamento iguais por bilhete;   * Quando um escalonamento deve ser feito, escolhe-se aleatoriamente um bilhete:     * Processos mais importantes podem receber mais bilhetes;     * Processos podem doar bilhetes para colaboração com outros.  \\--- PÁGINA 33 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **6\\. Loteria**  * Precisa garantir que todos terão sua vez de execução;   * Um modo é manter duas filas:     * Bilhetes já sorteados;     * Bilhetes ainda não sorteados.   * Quando a lista de não sorteados se esvazia, os bilhetes da lista de sorteados são transferidos a ela, reiniciando o processo.  \\--- PÁGINA 34 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **7\\. Fair-Share**  * O dono do processo é levado em consideração na partilha do tempo;   * Se um usuário A possui 8 processos e um usuário B possui apenas 2 processos:     * Com Round-Robin o usuário A ganharia 80% do uso da CPU;     * Com a distribuição justa, se a um usuário foi prometida certa fatia de tempo, ele a receberá, independente do número de processos (ex.: 50% para cada).  \\--- PÁGINA 35 \\---  ## **Algoritmo de Escalonamento: Interativos**  ### **7\\. Fair-Share**  * Usuário 1 \\- Processos: A, B, C, D   * Usuário 2 \\- Processo: E   * Foi prometido 50% da CPU a cada um e foi utilizado Round-Robin:     * A, E, B, E, C, E, D, E, A, E, ...   * Se 2/3 devem ir ao Usuário 1:     * A, B, E, C, D, E, A, B, E, ...  \\--- PÁGINA 36 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 2\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 8\\.  \\--- PÁGINA 37 \\---   Slide final com o logo da universidade e contato do professor.