\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Sincronização de Processos**  ### **Parte 3**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Condições de corrida e o problema da Seção Crítica**  *Este slide repete a definição de Condição de Corrida e Seção Crítica.*  \\--- PÁGINA 3 \\---  ## **Seção crítica: Requisitos**  *Este slide repete a lista dos 4 requisitos para uma boa solução do problema da seção crítica (Exclusão Mútua, Progresso Garantido, Espera Limitada, Independência da Arquitetura).*  \\--- PÁGINA 4 \\---  ## **Comunicação entre Processos: InterProcess Communication (IPC)**  *Este slide repete as questões importantes sobre IPC (como passar informação, evitar conflitos, sequenciamento).*  \\--- PÁGINA 5 \\---  ## **Seção crítica: Propostas de Solução**  * Espera ocupada (busy waiting)   * Sleep / WakeUp (primitivas \\- chamadas de sistema)   * Semáforos (variável de controle)   * Monitores (primitiva de alto nível)   * **Troca de Mensagens (ambiente de computação distribuída)**  \\--- PÁGINA 6 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  * **Semáforos e Monitores:**     * Projetados para exclusão mútua em processadores que compartilham algum espaço de memória;     * Não funcionam com sistemas distribuídos, em que cada processador (ou grupo de processadores) possui sua própria memória.   * Como passar informação entre diferentes máquinas?  \\--- PÁGINA 7 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  * **Implementação do link de comunicação:**     * **Físico:**       * Memória compartilhada       * Barramento de hardware       * Rede     * **Lógico:**       * Direto ou indireto       * Síncrono ou assíncrono       * Automático ou buffer explícito  \\--- PÁGINA 8 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  * Processos enviam e recebem mensagens em vez de ler e escrever em variáveis compartilhadas;   * Podem ser bloqueantes ou não-bloqueantes;   * Mecanismos de registro/confirmação recebimento e de envio;   * **Chamadas de sistema \\- Primitivas:**     * send(destino, \\&msg)     * receive(fonte, \\&smg)   * Se não houver mensagem disponível, o receptor pode bloquear até que haja alguma mensagem (blocked) ou retornar com mensagem de erro (unblocked).  \\--- PÁGINA 9 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  \\[Imagem: send Bloqueante vs. Não-bloqueante\\]   Dois diagramas de tempo ilustram a diferença.   (a) Primitiva send bloqueante: O cliente chama send, o kernel copia a mensagem e o cliente fica bloqueado (Client blocked) até que o envio termine.   (b) Primitiva send não-bloqueante: O cliente chama send, o kernel inicia o envio e retorna o controle imediatamente para o cliente, que continua sua execução (Client running) enquanto a mensagem está sendo enviada.   \\--- PÁGINA 10 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  * **Bloqueantes:** quando o processo que as executa fica bloqueado até que a operação seja bem sucedida.   * **Não-bloqueantes:** quando o processo que executar a primitiva continuar sua execução normal.   1. Envio Bloqueante → Recebimento Bloqueante (síncrono)   2. Envio Bloqueante → Recebimento Não-bloqueante (semi-síncrono)   3. Envio Não-bloqueante → Recebimento Bloqueante (semi-síncrono)   4. Envio Não-bloqueante → Recebimento Não-bloqueante (assíncrono)  \\--- PÁGINA 11 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  * Assumimos que as mensagens enviadas e não lidas são guardadas pelo S.O.   * Neste caso, usamos um número de mensagens igual ao do buffer.  \\[Imagem: Arquitetura de Fila de Mensagens (Kafka)\\]   Um diagrama mostrando múltiplos Producers enviando mensagens para um Kafka cluster (composto por Brokers). Do outro lado, um Consumer Group com múltiplos Consumers lê as mensagens do cluster.   \\--- PÁGINA 12 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  \\[Imagem: Pseudocódigo do Produtor/Consumidor com Troca de Mensagens\\]   O código mostra uma solução para o problema do Produtor/Consumidor usando send e receive. O consumidor inicialmente envia N mensagens vazias para o produtor, agindo como permissões. O produtor espera receber uma permissão (receive), constrói sua mensagem e a envia (send) para o consumidor. O consumidor espera receber uma mensagem do produtor, extrai o item e envia uma nova permissão vazia de volta.   \\--- PÁGINA 13 \\---  ## **Troca de Mensagens ou Passagem de Mensagens**  * **Envio Bloqueante → Recebimento Bloqueante**   * Mecanismos de comunicação síncronos:     * RPC (Remote Procedure Call);     * RMI (Remote Method Invocation \\- Java);     * Caixas postais (mailboxes); e     * Portos (ports).  \\--- PÁGINA 14 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  \\--- PÁGINA 15 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  * Um processo pode comandar a execução de um procedimento situado em outra máquina.   * O processo chamador deverá ficar bloqueado até que o procedimento chamado termine (mecanismo síncrono).   * Tanto a chamada quanto o retorno podem envolver a troca de mensagem, passando parâmetros.  \\[Imagem: Passos de uma RPC\\]   Um diagrama numera os 10 passos de uma RPC, mostrando o fluxo: a função cliente chama o stub cliente, que empacota os dados e os envia via rede. O stub servidor recebe, desempacota e chama a função servidor. O retorno faz o caminho inverso.   \\--- PÁGINA 16 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  * As mensagens trocadas em uma comunicação RPC são bem estruturadas e não são nada mais do que pacotes de dados.   * Cada mensagem é endereçada a um RPC daemon ouvinte para uma porta a um sistema remoto e cada uma delas contém a identificação da função específica a ser executada e os parâmetros que devem ser passados para a função.   * A porta é simplesmente um número incluído no início do pacote da mensagem.  \\--- PÁGINA 17 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  **Desafios:**  * Dificuldade de passagem de parâmetros por referência.   * Se servidor e cliente possuem diferentes representações de informação, existe a necessidade de conversão.   * Diferenças de arquitetura (e.g., big-endian vs. little-endian).   * **Falhas semânticas:** se o servidor para de funcionar quando executava uma RPC \\- O que dizer ao cliente? Principais abordagens: \\\"no mínimo uma vez\\\", \\\"exatamente uma vez\\\" e \\\"no máximo uma vez\\\".  \\--- PÁGINA 18 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  * **Diferentes representações de informação:**     * É necessário manter a atenção às diferentes formas de representação das informações entre clientes e servidores.     * Um exemplo são as representações conhecidas como **big-endian** e **little-endian**.     * Vários sistemas RPC apresentam uma representação dos dados independente da máquina. Essa representação é conhecida como **external data representation (XDR)**.  \\--- PÁGINA 19 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  * **Falhas semânticas:**     * **No mínimo uma vez (at-least-once):** O cliente fica retransmitindo o pedido até que tenha a resposta desejada.     * **Exatamente uma vez (maybe):** Cliente não sabe se o servidor processou o pedido ou não. Não há medidas de tolerância à falhas.     * **No máximo uma vez (at-most-once):** Se o servidor cai, o cliente saberá do erro, mas não saberá se a operação foi executada.  \\--- PÁGINA 20 \\---  ## **Troca de Mensagens: Remote Procedure Call (RPC)**  \\[Imagem: Tabela de Semânticas de Falha em RPC\\]   A tabela relaciona os mecanismos de tolerância a falhas (Retransmissão, Filtro de duplicatas) com a semântica resultante (Talvez, No mínimo uma vez, No máximo uma vez).   \\--- PÁGINA 21 \\---   Este slide repete a imagem do fluxo de execução de uma RPC da Parte 2 (ECOS01\\_03.2).   \\--- PÁGINA 22 \\---  ## **Troca de Mensagens: RMI (Remote Method Invocation) \\- Java**  \\--- PÁGINA 23 \\---  ## **Troca de Mensagens: RMI (Remote Method Invocation \\- Java)**  * Permite que um objeto ativo possa interagir com objetos de outras máquinas virtuais Java.  \\[Imagem: Arquitetura RMI do Java\\]   Um diagrama mostrando o fluxo do RMI. Um RMI Client localiza um Remote Object através do RMI Registry. O servidor (que contém o objeto remoto) primeiro registra (\\\"bind\\\") o objeto no Registry. Uma vez localizado, o cliente pode invocar métodos remotos no objeto.   \\--- PÁGINA 24 \\---  ## **Troca de Mensagens: Caixas postais (mailboxes)**  \\--- PÁGINA 25 \\---  ## **Troca de Mensagens: Caixas postais (mailboxes)**  * Estruturas de dados;   * São filas de mensagens não associadas, a princípio, a nenhum processo;   * Lugar para se colocar um certo número de mensagens (limitado).   * Mensagens são enviadas ou lidas da caixa postal e não diretamente dos processos.  \\[Imagem: Conceito de Mailbox\\]   Uma ilustração mostrando o Processo P1 colocando uma mensagem na \\\"P2's Mailbox\\\" e o Processo P2 pegando uma mensagem de sua própria mailbox.   \\--- PÁGINA 26 \\---   Este slide mostra dois diagramas mais detalhados do fluxo de comunicação via mailboxes entre cliente e servidor.   \\--- PÁGINA 27 \\---  ## **Troca de Mensagens: Portos (ports)**  \\--- PÁGINA 28 \\---  ## **Troca de Mensagens: Portos (ports)**  * Consiste em elementos do sistema que permitem a comunicação entre conjunto de processos.   * Conexão de dados virtual ou lógica, utilizada para que programas troquem informação diretamente. Ex.: TCP \\- numerados de 1 a 65535\\.   * Cada porto é como uma caixa postal, porém com um dono, que será o processo que o criar.  \\[Imagem: Tabela de Portas TCP/UDP comuns\\]   Uma tabela listando números de portas conhecidas e os protocolos/aplicações associados a elas (e.g., 21: FTP, 22: SSH, 80: HTTP, 443: SSL).   \\--- PÁGINA 29 \\---   Este slide mostra uma lista mais extensa de portas TCP/UDP comuns e seus serviços.   \\--- PÁGINA 30 \\---  ## **Problemas clássicos de sincronização: InterProcess Communication (IPC)**  \\--- PÁGINA 31 \\---  ## **Problemas clássicos de sincronização: InterProcess Communication (IPC)**  * Estes problemas apresentam modelos de comunicação entre processos que envolvem sincronização e paralelismo.  \\[Imagem: Modelos de processamento paralelo\\]   Diagramas ilustrando as taxonomias de Flynn: SISD, SIMD, MISD e MIMD, além de um modelo de Task Pool onde um Scheduler distribui tarefas para processadores.   \\--- PÁGINA 32 \\---  ## **Problemas clássicos de sincronização: InterProcess Communication (IPC)**  * Estes problemas apresentam modelos de comunicação entre processos que envolvem sincronização e paralelismo:     1. Produtor/consumidor     2. Leitores e escritores     3. Jantar dos filósofos  \\--- PÁGINA 33 \\---  ## **Produtor/Consumidor (Problema do Buffer Limitado)**  * Já foi apresentado e utilizado em assuntos anteriores.   * É composto por entidades produtoras e entidades consumidoras e pelo compartilhamento de uma área de armazenamento limitada.   * Auxiliou na modelagem dos principais protocolos da internet.  \\--- PÁGINA 34 \\---  ## **Produtor/Consumidor: TCP \\- Controle de congestionamento**  \\[Imagem: Diagrama de estados do controle de congestionamento TCP\\]   Um complexo diagrama de máquina de estados mostrando as fases do controle de congestionamento do TCP, como Slow Start, Congestion Avoidance e Fast Recovery, e as transições entre elas baseadas em recebimento de ACKs, dupACKs e timeouts.   \\--- PÁGINA 35 \\---   Este slide mostra outro gráfico do controle de congestionamento TCP, ilustrando o crescimento da janela de congestionamento (cwnd) ao longo do tempo.   \\--- PÁGINA 36 \\---  ## **Produtor/Consumidor (Problema do Buffer Limitado)**  \\[Imagem: Arquitetura RabbitMQ\\]   Um diagrama mostrando um sistema de mensageria com PRODUCER, EXCHANGE, BINDINGS e QUEUES que são lidas por um CONSUMER, ilustrando a arquitetura do RabbitMQ.   \\--- PÁGINA 37 \\---   Este slide mostra mais arquiteturas de mensageria, comparando RabbitMQ e Kafka.   \\--- PÁGINA 38 \\---  ## **Produtor/Consumidor (Problema do Buffer Limitado)**  * Consiste em um conjunto de processos que compartilham um mesmo buffer.   * Os processos produtores inserem informação no buffer. Os processos consumidores retiram informação deste buffer.   * Busca exemplificar de forma clara, situações de impasses que ocorrem no gerenciamento de processos de um sistema operacional.   * A solução precisa garantir a exclusão mútua e a sequência correta na execução das operações.  \\--- PÁGINA 39 \\---  ## **Leitores e escritores**  \\--- PÁGINA 40 \\---  ## **Leitores e escritores**  \\[Imagem: Ilustração do problema Leitores-Escritores\\]   Uma ilustração mostrando um grupo de \\\"Readers\\\" (leitores) e um grupo de \\\"Writers\\\" (escritores) tentando acessar um recurso compartilhado (uma estante de livros).  * Modela acessos a uma base de dados.   * Se um processo necessita escrever na base, nenhuma outra entidade pode estar realizando acesso a ela. Nem mesmo acesso de leitura.  \\--- PÁGINA 41 \\---  ## **Leitores e escritores**  * Suponha que a base de dados será compartilhada com diversos processos concorrentes. Alguns destes processos podem somente ler a base de dados, enquanto outros poderão realizar atualizações na mesma (leitura e escrita).   * A distinção entre estes papéis é feita definindo os primeiros como **leitores** e os últimos como **escritores**.  \\--- PÁGINA 42 \\---  ## **Leitores e escritores**  * Obviamente, se dois leitores acessam simultaneamente uma informação não há problema algum. Se um escritor ou um outro processo (leitor ou escritor) quiserem acessar simultaneamente a base de dados podem ocorrer alguns problemas.   * Para nos certificar que estes problemas não irão ocorrer, precisamos garantir que os escritores têm acesso exclusivo à base de dados enquanto a atualizam (bloqueiam a base de dados).  \\--- PÁGINA 43 \\---  ## **Leitores e escritores**  \\[Imagem: Regras de acesso para Leitores e Escritores\\]   \\*Dois diagramas:  * **Quando Leitores estão acessando:** Novos Readers podem entrar, mas Writers não podem.   * **Quando um Escritor está escrevendo:** Nenhum outro Reader ou Writer pode entrar.\\*  \\--- PÁGINA 44 \\---  ## **Leitores e escritores**  * Escritores devem bloquear a base de dados.   * **Leitores:**     * Se a base estiver desbloqueada:       * Se for o 1º Leitor, deve bloqueá-la para evitar Escritor.       * Se já houver outro Leitor, basta utilizar a base de dados.     * Ao sair, verificar se há outro Leitor:       * Se houver, deixa a base de dados bloqueada;       * Se não houver, desbloqueia a base de dados.  \\--- PÁGINA 45 \\---  ## **Leitores e escritores**  * O problema de leitores-escritores possui algumas variações:     1. A primeira delas requer que nenhum leitor seja mantido em espera a menos que um escritor tenha obtido permissão para utilizar o objeto compartilhado.  \\--- PÁGINA 46 \\---  ## **Leitores e escritores**  * **Variação 1 (cont.):** Em outras palavras, nenhum leitor deve esperar que outros leitores terminem somente porque um escritor está esperando.     * **Possível problema:** Inanição do Escritor.  \\--- PÁGINA 47 \\---  ## **Leitores e escritores**  * **Variação 2:** A segunda abordagem requer que, uma vez que o escritor está pronto, a ação de escrita deve ser realizada o mais rápido possível. Em outras palavras, se um escritor está aguardando para acessar um objeto, nenhum novo leitor deve começar a ler este objeto.  \\--- PÁGINA 48 \\---   Este slide mostra uma ilustração de um programador e um analista, representando leitores e escritores de código.   \\--- PÁGINA 49 \\---  ## **Leitores e escritores**  * Leitores: não requerem excluir uns aos outros (entre eles).   * Escritores: requerem excluir todos os outros (leitores e escritores).   * A escrita exige exclusão mútua de modo a garantir a consistência dos dados.  \\--- PÁGINA 50 \\---  ## **Leitores e escritores**  * O Bloqueio no problema Leitor-Escritor é a solução mais utilizada nas seguintes situações:     1. Em aplicações onde é fácil identificar que alguns processos somente leem os dados compartilhados e que outros processos somente atualizam os dados.     2. Em aplicações que possuem mais leitores do que escritores.  \\--- PÁGINA 51 \\---  ## **Leitores e escritores: Código exemplo**  \\[Imagem: Código C para o problema Leitores-Escritores\\]   Um trecho de código em C/Pthreads mostrando a implementação para as funções reader() e writer(). A solução usa dois mutex: mutex para proteger o contador de leitores (rc) e db para proteger o acesso à base de dados.   \\--- PÁGINA 52 \\---  ## **Jantar dos filósofos**  \\--- PÁGINA 53 \\---  ## **Jantar dos filósofos**  \\[Imagem: A mesa do jantar dos filósofos\\]   Uma ilustração de uma mesa redonda com cinco pratos e cinco hashis (garfos) intercalados.  * Cinco filósofos estão sentados ao redor de uma mesa circular para o jantar.   * Entre cada par de pratos existe apenas um hashi.   * Hashis precisam ser compartilhados de forma sincronizada.   * Cada filósofo precisa de 2 hashis.  \\--- PÁGINA 54 \\---  ## **Jantar dos filósofos**  * ... Utilização de recursos compartilhados.  \\--- PÁGINA 55 \\---  ## **Jantar dos filósofos**  * Os filósofos comem e pensam alternadamente.   * Além disso, quando comem, pegam apenas um hashi por vez.   * Se conseguirem pegar os dois hashis eles comem por alguns instantes e depois deixam os hashis nos locais originais.  \\--- PÁGINA 56 \\---  ## **Jantar dos filósofos**  * Foi proposto por Edsger W. Dijkstra (1965) como um problema de sincronização.   * Cada um dos 5 filósofos pode ser modelado conforme o seguinte comportamento:     while (true){         meditar         pegar o palito à sua esquerda         pegar o palito à sua direita         comer         soltar o palito à sua esquerda         soltar o palito à sua direita     }  * Pode levar a **Impasse (deadlock)** e **inanição (starvation)**.  \\--- PÁGINA 57 \\---  ## **Jantar dos filósofos**  **Proposta de solução \\- Deve seguir a sequência cíclica:**  * Pensar por um tempo   * Pegar os hashis (Lock Esquerdo, Lock Direito)   * Comer por um tempo   * Deixar os hashis (Unlock Esquerdo, Unlock Direito)   * Como evitar que fiquem bloqueados?  \\--- PÁGINA 58 \\---  ## **Jantar dos filósofos**  * **A proposta de solução anterior funciona bem?**   * **Possíveis problemas:**     * **Deadlock (ou Impasse):** todos os filósofos pegam um único hashi ao mesmo tempo;     * **Starvation (ou Inanição):** os filósofos ficam indefinidamente tentando pegar os hashis simultaneamente; ou nunca conseguem pegar dois hashis ao mesmo tempo.  \\--- PÁGINA 59 \\---  ## **Jantar dos filósofos**  * Como evitar múltiplas tentativas?     * Semáforo binário (up/down) – Exclusão mútua.     * Problema: somente um filósofo come por vez.  \\--- PÁGINA 60 \\---  ## **Jantar dos filósofos**  * O problema do jantar dos filósofos é considerado um problema clássico de sincronização pois é um exemplo de problema de controle de concorrência em larga escala.   * É a simples representação da necessidade de alocação de diversos recursos entre diversos processos de modo a não causar deadlock ou starvation.  \\--- PÁGINA 61 \\---  ## **Jantar dos filósofos**  * Várias soluções possíveis para o problema do deadlock podem ser substituídas por:     * Permitir no máximo quatro filósofos sentados à mesa simultaneamente.     * Permitir que um filósofo pegue seus hashis apenas se os dois estiverem disponíveis (para fazer isso, ele deve pegá-los em uma seção crítica).     * Usar uma solução assimétrica: um filósofo de número ímpar pega primeiro seu hashi esquerdo, enquanto um filósofo de número par pega seu hashi direito.  \\--- PÁGINA 62 \\---  ## **Jantar dos filósofos**  * Este problema é útil para modelar processos que competem por acesso exclusivo a um número limitado de recursos:     * Periféricos em geral, particularmente os não-preemptivos;     * O protocolo Ethernet utiliza parte desta solução para modelar o envio de dados na rede.   * Ajuda a modelar uma solução livre de starvation e deadlocks.  \\--- PÁGINA 63 \\---  ## **Jantar dos filósofos: Código exemplo**  *O slide mostra um pseudocódigo que ilustra uma solução com falhas para o problema, onde um filósofo pode morrer de fome (starvation) ao ficar tentando pegar e devolver o mesmo garfo para sempre. Uma segunda versão com tempos aleatórios de espera diminui a probabilidade de starvation, mas não a elimina.*  \\--- PÁGINA 64 \\---  ## **Impasse (Deadlock)**  \\[Imagem: Caricatura do Jantar dos Filósofos com Deadlock\\]   Uma famosa caricatura da Communications of the ACM mostrando cinco monges (filósofos) à mesa. Quatro deles estão em desespero, cada um segurando um hashi e sem conseguir pegar o segundo. O quinto, no centro, come tranquilamente com dois hashis.  * Um conjunto de processos bloqueados, cada um de posse de um recurso e esperando por outro, já obtido por algum outro processo no conjunto.   * **Condições necessárias:**     * Exclusão mútua     * Posse durante a espera     * Inexistência de preempção     * Espera circular  \\--- PÁGINA 65 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 2\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulos 5 e 6\\.  \\--- PÁGINA 66 \\---   Slide final com o logo da universidade e contato do professor.