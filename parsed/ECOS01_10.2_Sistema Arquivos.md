\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Sistema de Arquivos**  ### **Implementação**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Sistema de Arquivos: Implementação**  * **Visão do usuário**     * Como arquivos são nomeados?     * Que operações são permitidas?     * Como o diretório é implementado?   * **Visão do implementador**     * Como arquivos e diretórios são armazenados?     * Como o espaço em disco é gerenciado?     * Como tornar o sistema eficiente e confiável?  \\--- PÁGINAS 3-4 \\---  ## **Estrutura de armazenamento \\- Sistemas de arquivos**  * **tmpfs** \\- um sistema de arquivos \\\"temporário\\\" que é criado em memória principal volátil.   * **objfs** \\- um sistema de arquivos \\\"virtual\\\" que fornece aos depuradores acesso a símbolos do kernel.   * **ctfs** \\- um sistema de arquivos virtual que mantém informações de “contrato\\\" para gerenciar processos.   * **procfs** \\- um sistema de arquivos virtual que apresenta informações sobre todos os processos como um sistema de arquivos.   * **ufs, zfs** \\- sistemas de arquivos de uso geral.  \\--- PÁGINA 5 \\---  ## **Sistema de Arquivos: Implementação**  * Existem dois tipos de sistemas de arquivos:     1. Sistemas de disco (funciona em uma unidade de armazenamento); e     2. Sistema de arquivo em rede (armazenamento é feito em outro computador da rede).   * O **NTFS** é um sistema de arquivos de disco que utiliza estrutura de Árvore B+ e que foi desenhada para minimizar a fragmentação.   * O NTFS permite: nome alternativo, cota de armazenamento, pontos de montagem, compressão, criptografia, etc.  \\--- PÁGINA 6 \\---  ## **Sistema de Arquivos: Implementação**  * O sistema de arquivos de disco Linux **Extented File System (ext2)** pode gerenciar tamanho máximo de 4 TB.   * Em 2001 foi desenvolvido o **ext3** com **Journaling**. Em 2006 surge o **ext4** aumentando o tamanho máximo do disco para 1 EB.   * Os ext2, 3 e 4 separam explicitamente as propriedades do arquivo (**inode**) do dado.  \\--- PÁGINA 7 \\---  ## **Estrutura de armazenamento \\- Sistemas de arquivos**  * Da mesma forma que um arquivo deve ser aberto antes de ser usado, um sistema de arquivos deve ser **montado** antes que possa ficar disponível.   * O procedimento de montagem é simples: O sistema operacional recebe o nome do dispositivo e o **ponto de montagem** — a locação dentro da estrutura de arquivos onde o sistema de arquivos deve ser anexado.  \\--- PÁGINA 8 \\---  ## **Sistema de Arquivos: Implementação**  ### **Layout do sistema de arquivos**  * Arquivos são armazenados em discos que podem ser divididos em uma ou mais partições.   * Setor 0 do disco é do **MBR (Master Boot Record)**:     * Usado para iniciar o computador;     * Onde fica alocada a tabela de partição, com o endereço inicial e final de cada partição, sendo uma delas marcada como ativa;     * Durante o boot, a BIOS lê e executa o MBR.  \\--- PÁGINA 9 \\---  ## **Sistema de Arquivos: Implementação**  ### **Layout do sistema de arquivos \\- MBR**  * O programa na MBR localiza a partição ativa, lê seu primeiro bloco (**boot block**) e executa-o.   * O programa no bloco de boot carrega o SO daquela partição.  \\[Imagem: Layout de uma partição de disco\\]   A imagem mostra um disco (Entire disk) com o MBR no início. Uma das partições do disco (Disk partition) é expandida para mostrar sua estrutura interna: Boot block, Superblock, Free space mgmt, I-nodes, Root dir, e Files and directories.   \\--- PÁGINA 10 \\---   Este slide mostra dois diagramas mais detalhados da estrutura do MBR e do layout de um disco com partições Windows e Linux.   \\--- PÁGINA 11 \\---   Este slide mostra um diagrama ainda mais detalhado da estrutura do MBR, com a tabela de partições e o setor de boot.   \\--- PÁGINA 12 \\---   Este slide mostra um \\\"dump\\\" hexadecimal de um MBR, com anotações explicando os campos como código de boot, tabela de partição e assinatura mágica (0x55AA).   \\--- PÁGINA 13 \\---  ### **MBR vs. GPT**  * **MBR:**     * Mais antigo;     * Limitado a 2 TB;     * Limitado a 4 partições primárias.   * **GPT (GUID Partition Table):**     * Qualquer tamanho;     * Número ilimitado de partições.  \\[Imagem: Comparação MBR vs. GPT\\]   Dois diagramas comparam o esquema de particionamento MBR (com partições primárias e estendidas) com o esquema GPT (com um cabeçalho primário, um array de entradas de partição e um cabeçalho de backup no final do disco).   \\--- PÁGINA 14 \\---   Este slide mostra um \\\"dump\\\" hexadecimal de uma GPT, detalhando a localização e o conteúdo do cabeçalho GPT e do array de partições.   \\--- PÁGINA 15 \\---  ## **Sistema de Arquivos: Implementação \\- BIOS vs UEFI**  \\[Imagem: Comparação de Boot BIOS vs. UEFI\\]   \\*Dois fluxogramas:  * **BIOS BOOTING:** BIOS \\-\\> MBR \\-\\> BOOT LOADER (Kernel) \\-\\> OPERATING SYSTEM.   * UEFI BOOTING: UEFI \\-\\> EFI BOOT LOADER \\-\\> KERNEL \\-\\> OPERATING SYSTEM.     O fluxo UEFI é mais direto e seguro.\\*  \\--- PÁGINA 16 \\---  ## **Sistema de Arquivos: Proteção**  \\--- PÁGINA 17 \\---  ## **Sistema de Arquivos: Proteção**  * Quando informações são armazenadas em um sistema de computação, queremos mantê-las protegidas contra danos físicos (**confiabilidade**) e acesso indevido (**proteção**).   * A confiabilidade geralmente é fornecida por cópias duplicadas dos arquivos (backups).   * A proteção pode ser fornecida de muitas maneiras. Em um sistema multiusuário pode ser utilizado o controle de acesso e as permissões.  \\--- PÁGINA 18 \\---  ## **Sistema de Arquivos: Proteção**  ### **Tipos de acesso ao sistema de arquivos**  * Os mecanismos de proteção fornecem acesso controlado limitando os tipos de acesso a arquivos que podem ser feitos. Vários tipos de operações diferentes podem ser controladas:     * Leitura.     * Gravação.     * Execução.     * Acréscimo.     * Exclusão.     * Listagem do nome e dos atributos dos arquivos.  \\--- PÁGINA 19 \\---  ## **Sistema de Arquivos: Proteção**  ### **Controle de acesso ao sistema de arquivos**  * A abordagem mais comum é tornar o acesso dependente da identidade do usuário.   * O esquema mais geral é associar a cada arquivo e diretório uma **lista de controle de acesso (ACL — access control list)** especificando nomes de usuários e os tipos de acesso permitidos.  \\--- PÁGINA 20 \\---  ## **Controle de acesso ao sistema de arquivos \\- ACL**  * O principal problema das listas de acesso é seu tamanho.   * Construir a lista pode ser tedioso e a entrada do diretório se torna de tamanho variável.  \\--- PÁGINA 21 \\---  ## **Controle de acesso ao sistema de arquivos \\- ACL**  * Esses problemas podem ser resolvidos com o uso de uma versão condensada da lista de acesso. Muitos sistemas reconhecem três classificações de usuários:     * **Proprietário (owner):** O usuário que criou o arquivo.     * **Grupo (group):** Um conjunto de usuários que estão compartilhando o arquivo.     * **Universo (others):** Todos os outros usuários no sistema.  \\--- PÁGINA 22 \\---  ## **Sistema de Arquivos: Proteção**  \\[Imagem: Permissões de arquivo no Unix\\]   Um diagrama explicando o formato das permissões no Unix: o primeiro caractere indica o tipo de arquivo (-, d, l, etc.), seguido por três conjuntos de três caracteres (rwx) para as permissões do dono (owner), do grupo (group) e de outros (others).   \\--- PÁGINA 23 \\---  ## **Sistema de Arquivos: Layout**  \\--- PÁGINA 24 \\---  ## **Sistema de Arquivos: Layout do sistema de arquivos \\- MBR**  * O **superblock** contém os parâmetros-chave, como tamanho e número de blocos, ID do sistema de arquivos (conhecido como número mágico), além de outros campos.   * É lido para a memória no boot.  \\--- PÁGINA 25 \\---  ## **Sistema de Arquivos: Layout do sistema de arquivos \\- MBR**  * Informação a respeito de blocos livres é armazenado através de **mapa de bits** ou de **lista de ponteiros**.  \\--- PÁGINA 26 \\---  ## **Sistema de Arquivos: Layout do sistema de arquivos \\- MBR**  * A estrutura de dados dos arquivos é representada pelos **i-nodes**.   * **i-node \\- Index-node.**   * Existe uma por arquivo, com informações e localização.   * Utilizada no Unix/Linux.  \\--- PÁGINAS 27-28 \\---   Estes slides destacam as seções Root dir (diretório-raiz) e Files and directories no layout da partição.   \\--- PÁGINA 29 \\---  ## **Sistema de Arquivos: Implementação \\- Implementação por Journaling**  \\[Imagem: Opções de sistema de arquivos\\]   Capturas de tela de instaladores de sistemas operacionais (Linux e macOS) mostrando as várias opções de sistemas de arquivos disponíveis, como Ext4, Ext3, XFS, APFS, FAT32, etc. Muitos são descritos como \\\"journaling file system\\\".   \\--- PÁGINA 30 \\---  ## **Sistema de Arquivos: Implementação \\- Implementação por Journaling**  * Considere a remoção de um arquivo no Unix:     1. Remoção do arquivo de seu diretório;     2. Liberação do i-node para o conjunto de i-nodes livres;     3. Devolução dos blocos livres no disco.  \\--- PÁGINA 31 \\---  ## **Sistema de Arquivos: Implementação \\- Implementação por Journaling**  * E se o sistema parar ao final da primeira etapa?     * Existirão i-nodes com blocos não acessíveis e com endereços não-realocáveis.   * E ao final da segunda etapa?     * Os blocos serão perdidos.  \\--- PÁGINA 32 \\---  ## **Sistema de Arquivos: Implementação \\- Implementação por Journaling**  * Técnica para criar uma certa robustez diante das falhas.   * Mantém-se um **log – journal**.   * Controla as informações do que o sistema de arquivos irá fazer **antes** que ele efetivamente o faça (checkpoints).   * Sistemas de arquivo Journaling: Windows \\- NTFS; Linux \\- ext3 em diante.  \\--- PÁGINA 33 \\---  ## **Sistema de Arquivos: Implementação \\- Implementação por Journaling \\- Funcionamento**  * Procedimento:     1. Grava a transação completa no log no disco;     2. Lê de volta para a memória, para verificar a sua integridade.     3. Só então as operações têm início.     4. Quando uma operação é concluída, sua entrada no log é marcada.  \\--- PÁGINA 34 \\---   Este slide explica que as operações em um sistema de arquivos com journaling devem ser idempotentes, ou seja, poderem ser repetidas sem causar danos caso o sistema falhe no meio da operação.   \\--- PÁGINA 35 \\---  ## **Sistema de Arquivos: Implementação \\- Implementando arquivos**  * Como os arquivos são alocados no disco?   * Diferentes técnicas por diferentes SOs:     * Alocação contínua;     * Alocação com lista encadeada;     * Alocação com lista enc. utilizando uma tabela na memória (FAT);     * i-nodes.  \\--- PÁGINAS 36-39 \\---  ## **Sistema de Arquivos: Implementação \\- Alocação contínua**  * **Vantagens:** Simples de implementar e alto desempenho na leitura sequencial.   * **Desvantagens:** O disco se torna fragmentado com o tempo. É preciso saber o tamanho final do arquivo de antemão.  \\--- PÁGINA 40 \\---   Este slide repete a lista de técnicas de alocação de arquivos.   \\--- PÁGINAS 41-42 \\---  ## **Sistema de Arquivos: Implementação \\- Alocação com lista encadeada**  * Cada arquivo é uma lista ligada de blocos do disco. Cada bloco contém um ponteiro para o próximo.   * **Vantagens:** Resolve o problema da fragmentação externa.   * **Desvantagens:** Acesso aleatório é muito lento. Um pouco de espaço em cada bloco é perdido para o ponteiro.  \\--- PÁGINA 43 \\---   Este slide repete a lista de técnicas de alocação de arquivos.   \\--- PÁGINAS 44-47 \\---  ## **Sistema de Arquivos: Implementação \\- Alocação com lista encadeada utilizando uma tabela na memória (FAT)**  * O ponteiro para o próximo bloco é movido do bloco de dados para uma tabela na memória, a **FAT (File Allocation Table)**.   * O diretório armazena apenas o endereço do primeiro bloco.   * Toda a cadeia de um arquivo está na memória, tornando o acesso aleatório muito mais rápido.   * **Desvantagem:** A tabela FAT inteira deve estar na memória, o que pode consumir muito espaço para discos grandes.  \\--- PÁGINA 48 \\---   Este slide repete a lista de técnicas de alocação de arquivos.   \\--- PÁGINAS 49-51 \\---  ## **Sistema de Arquivos: Implementação \\- i-Nodes**  * Utilizados nos Sistemas Operacionais Unix e Linux.   * Cada arquivo possui uma estrutura chamada **i-node** que contém os atributos e os endereços de disco dos blocos do arquivo.   * **Vantagem:** O i-node só é carregado na memória quando o arquivo é aberto, economizando espaço em comparação com a FAT.  \\--- PÁGINA 52 \\---  ## **Sistema de Arquivos: Implementação \\- i-Nodes**  * **Desvantagem:** Cada i-node tem espaço para um número fixo de endereços de disco.   * **Solução:** Para arquivos grandes, os últimos ponteiros no i-node apontam para **blocos de indireção** (blocos que contêm mais ponteiros para blocos de dados), podendo haver indireção simples, dupla ou tripla.  \\--- PÁGINAS 53-54 \\---   Estes slides mostram diagramas detalhados da estrutura de um i-node, incluindo os ponteiros diretos e indiretos.   \\--- PÁGINAS 55-62 \\---   Estes slides percorrem um exemplo detalhado de como o sistema de arquivos navega pela estrutura de diretórios e i-nodes para localizar os blocos de dados do arquivo /usr/andy/Texto.txt.   \\--- PÁGINA 63 \\---  ## **Sistema de Arquivos: Gerenciamento de blocos livres**  \\--- PÁGINAS 64-66 \\---  ## **Sistema de Arquivos: Gerenciamento de blocos livres**  ### **1\\) Lista ligada de blocos de disco**  * Todos os blocos livres são mantidos em uma lista encadeada.   * Um ponteiro para o primeiro bloco livre é mantido em um local específico.   * **Problema:** Pouco eficiente se for necessário varrer a lista.   * **Alternativa:** Agrupar ponteiros para múltiplos blocos livres em um único bloco, formando uma lista de listas.  \\--- PÁGINA 67 \\---   Este slide ilustra um problema com arquivos temporários, que podem causar muita E/S ao alocar e liberar blocos da lista de livres no disco.   \\--- PÁGINA 68 \\---  ## **Sistema de Arquivos: Gerenciamento de blocos livres**  ### **Lista ligada de blocos de disco**  * **Vantagens:** Requer menos espaço se o disco está quase cheio.   * **Desvantagens:** Requer mais espaço se o disco está vazio; dificulta a alocação contígua.  \\--- PÁGINA 69 \\---  ## **Sistema de Arquivos: Gerenciamento de blocos livres**  ### **2\\) Mapa de bits**  * Um disco com n blocos requer um mapa com n bits, onde cada bit representa um bloco (0=livre, 1=ocupado).   * **Vantagem:** Facilita encontrar blocos contíguos.   * **Desvantagem:** Torna-se lento quando o disco está cheio, pois é necessário varrer o mapa.  \\--- PÁGINA 70 \\---   Este slide mostra o layout de um grupo de blocos no sistema de arquivos ext2, que inclui bitmaps para blocos e inodes.   \\--- PÁGINAS 71-72 \\---  ## **Sistema de Arquivos: Recuperação de dados**  * **Verificação de Consistência:** Um programa como o fsck no UNIX compara os metadados (diretórios, i-nodes) com os dados nos blocos para corrigir inconsistências.   * **Sistemas de Arquivos Estruturados em Log (Journaling):** Usam um log para registrar as operações antes de executá-las, garantindo a recuperação rápida e consistente após uma falha.  \\--- PÁGINA 73 \\---  ## **Sistema de Arquivos: Informações adicionais \\- NFS (Network File System)**  * Um exemplo de sistema de arquivos em rede cliente-servidor. Permite que um cliente monte um diretório de um servidor remoto e o acesse como se fosse local.  \\--- PÁGINAS 74-75 \\---  ## **Sistema de Arquivos: Informações adicionais \\- LDAP e Active Directory**  * **LDAP (Lightweight Directory Access Protocol):** Um protocolo para acessar e manter serviços de informação de diretório distribuído.   * **Active Directory:** A implementação da Microsoft de serviços de diretório, baseada em LDAP, para gerenciamento centralizado de usuários, computadores e políticas em uma rede Windows.  \\--- PÁGINA 76 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 4\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulos 12-13.  \\--- PÁGINA 77 \\---   Slide final com o logo da universidade e contato do professor.