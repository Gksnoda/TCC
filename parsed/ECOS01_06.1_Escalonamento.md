\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Escalonamento**  ### **Parte 1**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Recapitulando: Sistema Operacional**  * Oferece serviços de tratamento de interrupções e exceções; gerenciamento de arquivos, memória e dispositivos; suporte à rede; proteção e segurança. Realiza abstração e gerência de recursos limitados.   * Com relação ao tipo de tarefas, podemos classificá-los em:     * Monotarefa     * Multitarefa (Multiprogramação):       * Em lote (Batch)       * Tempo Compartilhado (Time-sharing)       * Tempo-Real  \\--- PÁGINA 3 \\---  ## **Recapitulando: Sistema Operacional Multitarefa**  Possui diversos processos que competem pela CPU. Surge, assim, a necessidade de alguma entidade para escalonar a CPU entre os processos.  \\[Imagem: Visão geral de um sistema computacional\\]   O diagrama mostra a relação entre os componentes de um sistema. Na base está o \\\"computer hardware\\\". Acima, o \\\"operating system\\\". Sobre o SO, rodam os \\\"system and application programs\\\" (compilador, assembler, editor de texto, etc.). No topo, múltiplos usuários (user 1, user 2, ..., user n) interagem com esses programas.   \\--- PÁGINA 4 \\---  ## **Recapitulando: Processos**  * É uma instância de um programa em execução;   * Pode ser executado em primeiro ou em segundo plano (daemon);   * Pode ser orientado à CPU ou à operações de E/S;   * Possui espaço de endereçamento de memória reservado;   * Possui um Bloco de Controle de Processo (PCB) que mantém informações relacionadas a seu contexto.  \\[Imagem: Colagem de diagramas sobre processos\\]   A imagem combina três diagramas vistos anteriormente: o layout de um processo na memória (pilha, heap, dados, texto), a ilustração de rajadas de CPU e E/S, e a estrutura de um Bloco de Controle de Processo (PCB).   \\--- PÁGINA 5 \\---  ## **Recapitulando: Sistema Operacional Multitarefa**  * Possui diversos processos que competem pelo uso da CPU.   * **Despachante (Dispatcher):** módulo que realiza o armazenamento e recuperação dos contextos dos processos e atualiza os PCBs.   * **Escalonador (Scheduler):** módulo que controla a mudança de estado dos processos, definindo o próximo processo a ser executado.  \\[Imagem: Diagrama de fluxo do escalonamento de processos\\]   Um diagrama de blocos mostrando a fila de prontos (ready queue) alimentando a CPU. A partir da CPU, um processo pode ir para uma fila de E/S (I/O queue), voltar para a fila de prontos ao fim do seu quantum (time slice expired), criar um processo filho (fork a child) ou esperar por uma interrupção (wait for an interrupt).   \\--- PÁGINA 6 \\---  ## **Troca de contexto**  * Também conhecido como chaveamento ou mudança de contexto é o processo computacional de armazenar e restaurar o estado (contexto) de uma CPU de forma que múltiplos processos possam compartilhar uma única instância de CPU.   * Este processo garante que quando o contexto anterior armazenado for restaurado, o ponto de execução voltará ao mesmo estado que foi deixado durante o armazenamento.   * A mudança de contexto leva a uma sobrecarga de tempo:     * É preciso salvar as informações do processo que está deixando/entrando a/na CPU em seu PCB (Bloco de Controle de Processos).     * Salvar o conteúdo dos registradores.  \\--- PÁGINA 7 \\---  ## **Troca de contexto**  \\[Imagem: Diagrama de troca de contexto\\]   O diagrama mostra as linhas do tempo para o process P₀, process P₁ e o operating system. Quando P₀ é interrompido, o SO salva seu estado no PCB₀, carrega o estado de P₁ a partir do PCB₁ e P₁ começa a executar. O processo se inverte quando P₁ é interrompido.   \\--- PÁGINA 8 \\---  ## **Despacho e Escalonamento: Sistema Operacional Multitarefa**  * **Despachante (Dispatcher):** módulo que realiza o armazenamento e recuperação dos contextos dos processos e atualiza os PCBs.     * Armazena e recupera o contexto;     * Atualiza as informações no PCB;     * Processo relativamente rápido (0,1ms).   * **Escalonador (Scheduler):** módulo que controla a mudança de estado dos processos, definindo o próximo processo a ser executado.     * Escolhe a próxima tarefa a receber o processador;     * Parte mais demorada.  \\--- PÁGINA 9 \\---  ## **Escalonamento: Sistema Operacional Multitarefa**  * Quando o Escalonador é chamado?     * Quando um novo processo é criado:       * Por quem ele foi criado? Qual a prioridade deste processo?       * Quando um processo cria outro, qual executar? Pai ou filho?     * Um processo chegou ao fim e um processo pronto deve ser executado:       * É necessário definir quem será o próximo da fila.     * Quando um processo é bloqueado (dependência de E/S) e outro deve ser executado.  \\--- PÁGINA 10 \\---  ## **Escalonamento: Sistema Operacional Multitarefa**  * Quando ocorre uma resposta de E/S, o escalonador deve:     * Executar o processo que estava esperando este evento?     * Continuar executando o processo que já estava sendo executado?     * Executar um terceiro processo que esteja pronto para ser executado?  \\--- PÁGINA 11 \\---  ## **Escalonamento de processos**  * Deve possuir um algoritmo que se preocupe com 5 regras:     * **Justiça** \\- Todos processos devem ter acesso a CPU (tempo de espera)     * **Eficiência** – buscar a máxima utilização da CPU     * **Minimizar o Tempo de Resposta**     * **Turnaround** \\- Minimiza os usuários batch. Tempo para conclusão do processo (alocação \\+ fila \\+ execução CPU \\+ execução E/S)     * **Throughput** – Maximizar o número de jobs processados   * A partir da finalização da execução de um processo ou de sua parcela de tempo (quantum), qual será o novo processo a ser executado?   * Como esta escolha pode ser feita?  \\--- PÁGINA 12 \\---  ## **Escalonamento de processos**  * Com relação ao escalonamento da CPU, pode ser classificado em:     * **Não-preemptivo:**       * Implementação mais simples do escalonador.       * Processo utiliza o processador durante o tempo que quiser.       * O processo deixa/libera a CPU nas seguintes condições:         * Término da execução; ou         * Solicitação de operação de E/S (voluntário).  \\--- PÁGINA 13 \\---  ## **Escalonamento de processos**  * Com relação ao escalonamento da CPU, pode ser classificado em:     * **Preemptivo:**       * Escalonador mais complexo.       * Processo utiliza o processador durante uma parcela de tempo definida (time-sharing).       * Compartilhamento da CPU é garantido. Periodicamente o escalonador interrompe o processo em execução e muda-o para o estado \\\"pronto\\\".       * O processo deixa/libera a CPU nas seguintes condições:         * Término da execução; ou         * Solicitação de operação de E/S ou         * Término do quantum.  \\--- PÁGINA 14 \\---  ## **Qual o próximo processo a ser enviado à CPU?**  \\[Imagem: Gerenciadores de Tarefas de diferentes SOs\\]   A imagem exibe três exemplos de gerenciadores de tarefas: o comando top do Linux, o Activity Monitor do macOS e o Task Manager do Windows, todos listando processos em execução e seu consumo de recursos.   \\--- PÁGINA 15 \\---  ## **Processos**  * Podem ser descritos como:     * **I/O-bound:** gastam mais tempo fazendo E/S do que computação.     * **CPU-bound:** Gastam mais tempo com computação.   * Podemos classificá-los por:     * **Uso de recursos:** temos os processos convencionais e os de tempo real (de sistema).       * No Linux, os processos de tempo real recebem prioridade entre 1 e 99, enquanto os processos convencionais recebem prioridade entre 100 e 139 (padrão 120).     * **Tipo de execução:** temos os interativos, em série ou tempo real.  \\[Imagem: Faixa de prioridades do Linux\\]   Um diagrama linear mostrando a faixa de prioridades no Linux, de 0 a 139\\. A faixa de 0-99 é para processos de \\\"Real-Time\\\" e a faixa de 100-139 é para processos \\\"Normal\\\", com prioridades mais altas à esquerda.   \\--- PÁGINA 16 \\---  ## **S \\- Em série, I \\- Interativos, R \\- Tempo real**  \\[Imagem: Saída do comando top\\]   A imagem mostra novamente a saída do comando top, destacando exemplos de processos em série (S), interativos (I) e de tempo real (R) com base em suas características e prioridades (PR).   \\--- PÁGINA 17 \\---  ## **Algoritmos de escalonamento**  * Sistemas Batch   * Sistemas Interativos   * Sistemas Tempo Real  \\--- PÁGINA 18 \\---  ## **Algoritmo de escalonamento: Sistemas Batch**  \\--- PÁGINA 19 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  * Refere-se a um processamento de dados que ocorre através de um lote de tarefas enfileiradas, de modo que o sistema operacional só processa a próxima tarefa após o término completo da tarefa anterior.   * Estão relacionados ao tempo de job.     1. FCFS (First-Come, First-Served)     2. SJF (Shortest Job First)     3. Priority-based Scheduling     4. SRTN (Shortest Remaining-Time Next)  \\--- PÁGINA 20 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **1\\) FCFS (First-Come, First-Served)**  * Não-preemptivo;   * Processos são executados na CPU seguindo a ordem de requisição;   * Fácil de entender e programar (FIFO);   * Processos só são interrompidos por uma solicitação de E/S;   * **Desvantagem:** Ineficiente quando há processos que demoram na sua execução.  \\--- PÁGINA 21 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **1\\) FCFS (First-Come, First-Served)**  \\[Imagem: Filas no escalonamento FCFS\\]   Diagrama mostrando uma fila de prontos (Ready queue) onde os processos P₀, P₁, P₃... são enfileirados. O processo no início da fila vai para o estado Running. Se ele bloqueia por E/S (Block on I/O), vai para uma fila de espera (Waiting queues) e, ao terminar, volta para a fila de prontos.   \\--- PÁGINA 22 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **1\\) FCFS (First-Come, First-Served)**  \\[Imagem: Gráfico de Gantt para FCFS\\]   Um gráfico de Gantt mostrando a execução dos processos P0, P1, P2 e P3. A tabela mostra os tempos de chegada e execução de cada um. P0 executa de 0 a 5, P1 de 5 a 8, P2 de 8 a 16 e P3 de 16 a 22\\.   \\--- PÁGINA 23 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **1\\) FCFS (First-Come, First-Served)**  *O slide mostra novamente o gráfico e a tabela da página 22, agora com o cálculo do tempo de espera para cada processo e o tempo médio de espera, que resulta em 5,75.*  \\--- PÁGINA 24 \\---  ## **Turnaround Time**  * Em sistemas operacionais é o tempo que o S.O. gasta para organizar os processos entre si: requisitar recursos, criar o lote de execução, decidir qual processo vai ser executado.   * Em suma, é o tempo total contado desde a submissão do processo até sua conclusão. Leva em consideração o tempo de espera.  \\--- PÁGINA 25 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **2\\) SJF (Shortest Job First) ou SJN (Shortest Job Next)**  * Não-preemptivo;   * Menor processo da lista é executado primeiro;   * Deve-se prever o tempo de execução do processo;   * Menor turnaround (médio);   * **Desvantagens:**     * Todos os jobs precisam ser conhecidos de antemão;     * Se muitos jobs curtos começarem a chegar, os longos podem demorar a ser executados (possibilidade de inanição \\- starvation).  \\--- PÁGINA 26 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **2\\) SJF (Shortest Job First) ou SJN (Shortest Job Next)**  \\[Imagem: Tabela de processos para SJF\\]   Uma tabela com 4 processos (P0, P1, P2, P3) com seus respectivos tempos de chegada e de execução. O slide está incompleto, sem o gráfico de Gantt correspondente.   \\--- PÁGINA 27 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **2\\) SJF (Shortest Job First) ou SJN (Shortest Job Next)**  *O slide mostra novamente a tabela, agora com o cálculo do tempo médio de espera, que resulta em 5,25. O gráfico de Gantt ainda está ausente, mas os tempos de serviço indicam a ordem de execução: P0, P1, P3, P2.*  \\--- PÁGINA 28 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **2\\) SJF (Shortest Job First) ou SJN (Shortest Job Next)**  \\[Imagem: Tabela de exemplo do SJF\\]   Uma tabela mostrando 4 processos que chegam no tempo 0, com diferentes tempos de rajada (Burst Time). A tabela já está preenchida com o tempo de conclusão, turnaround e tempo de espera para cada um, assumindo a execução na ordem P4, P1, P3, P2.   \\--- PÁGINA 29 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **2\\) SJF (Shortest Job First) ou SJN (Shortest Job Next)**  \\[Imagem: Gráfico de Gantt para o exemplo SJF\\]   Um gráfico de Gantt ilustrando a execução do exemplo da página 28\\. A ordem de execução é P4 (0-3), P1 (3-9), P3 (9-16) e P2 (16-24), seguindo o critério do trabalho mais curto primeiro.   \\--- PÁGINA 30 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **3\\) Priority-based Scheduling**  * Não-preemptivo;   * Cada processo recebe um nível de prioridade;   * Processos com a mesma prioridade são executados de acordo com sua chegada na fila (FCFS / FIFO);   * A prioridade pode ser definida de acordo com requisitos de memória, de tempo ou necessidade de outros recursos.  \\--- PÁGINA 31 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **3\\) Priority-based Scheduling**  \\[Imagem: Tabela de processos para Escalonamento por Prioridade\\]   Uma tabela com 4 processos (P0, P1, P2, P3) com seus tempos de chegada, execução e uma coluna de prioridade.   \\--- PÁGINA 32 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **3\\) Priority-based Scheduling**  *O slide repete a tabela e calcula o tempo médio de espera, que resulta em 6\\. A ordem de execução, baseada na prioridade (menor número \\= maior prioridade), seria P0, P2, P1, P3.*  \\--- PÁGINA 33 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **4\\) SRTN (Shortest Remaining-Time Next)**  * Preemptivo (quantum);   * Versão preemptiva do SJF (Shortest Job First);   * Processos com menor tempo *restante* são executados primeiro.  \\--- PÁGINA 34 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **4\\) SRTN (Shortest Remaining-Time Next)**  \\[Imagem: Tabela de exemplo do SRTN\\]   Uma tabela com 6 processos (P1 a P6) com diferentes tempos de chegada e de rajada. As colunas para tempo de conclusão, turnaround e tempo de espera já estão preenchidas com base na execução do algoritmo SRTN.   \\--- PÁGINA 35 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **4\\) SRTN (Shortest Remaining-Time Next)**  \\[Imagem: Gráfico de Gantt para o exemplo SRTN\\]   Um gráfico de Gantt mostrando a execução preemptiva do exemplo da página 34\\. P1 começa mas é interrompido pela chegada de P2 (que tem burst menor), que é interrompido por P3, e assim por diante. O gráfico mostra as várias preempções até que todos os processos sejam concluídos.   \\--- PÁGINA 36 \\---  ## **Algoritmo de Escalonamento: Sistemas Batch**  ### **4\\) SRTN (Shortest Remaining-Time Next)**  * **Vantagens:**     * Aumento da vazão com a execução de um maior número de processos em menos tempo;     * Processos de rajadas (bursts) curtas são finalizados rapidamente.   * **Desvantagens:**     * Não é possível prever o tempo exato de execução de todos os processos.     * Processos longos terão sua execução postergada, criando a possibilidade de inanição.  \\--- PÁGINA 37 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 2\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 8\\.  \\--- PÁGINA 38 \\---   Slide final com o logo da universidade e contato do professor.