\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Processos**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Processos versus Programas**  **Programa:**  * Pode ter várias instâncias em execução (em diferentes processos).   * É um algoritmo codificado.   * Representa a forma como o programador vê a tarefa a ser executada.  **Processo:**  * É único.   * Código acompanhado de dados e estado.   * Forma pela qual o Sistema Operacional vê um programa e possibilita sua execução.  \\--- PÁGINA 3 \\---  ## **Processos**  **Processo em Primeiro Plano (foreground):** Interage diretamente com o usuário.  **Processo em Segundo Plano (background \\- daemon):** possuem funções específicas que independem do usuário.  **Cada processo possui:**  * Conjunto de instruções (código executável);   * Espaço de endereçamento (espaço reservado/exclusivo para que o processo possa ler e escrever);   * Contexto de hardware (valores nos registradores: PC, Pilha, etc);   * Contexto de software \\- descritores de S.O. (atributos como lista de arquivos abertos, variáveis, segurança, estado do processo, etc).  \\--- PÁGINA 4 \\---  ## **Processos**  Um sistema operacional executa uma variedade de programas:  * Sistemas Batch (lote) \\- Jobs (tarefas)   * Sistemas de Tempo Compartilhado \\- programas do usuário ou tarefas  **Processo** \\- um programa em execução; sua execução deve progredir de forma sequencial.  Um processo possui:  * Contador de programa   * Pilha (stack)   * Seção de dados  \\[Imagem: Layout de um processo na memória\\]   O diagrama mostra as seções da memória de um processo. De baixo para cima: text (código), data (variáveis globais), heap (memória alocada dinamicamente, que cresce para cima), uma área livre, e stack (pilha para chamadas de função, que cresce para baixo).   \\--- PÁGINA 5 \\---  ## **Processos: Espaço de endereçamento**  * **Texto:** código executável do(s) programa(s);   * **Dados:** as variáveis;   * **Pilha de Execução:**     * Controla a execução do processo     * Empilha as chamadas a procedimentos, seus parâmetros e variáveis locais, etc.  \\--- PÁGINA 6 \\---  ## **Processos: Gerenciamento**  * **Gerenciador por admissão:** escolhe qual processo irá executar e quando, de acordo com sua prioridade. Geralmente utilizado em sistemas de tempo real;   * **Gerenciador por tempo médio;**   * **Gerenciador despachante:** define os processos a serem executados de acordo com os eventos ocorridos no sistema.  Os gerenciadores possuem algoritmos para garantir a troca de processos de maneira correta e organizada. São exemplos de estratégias utilizadas: FIFO; Pipes unidirecionais (FIFO controlada pelo S.O.); Fila de mensagem; memória compartilhada.  \\--- PÁGINA 7 \\---  ## **Processos: Tabela de Controle de Processos (PCB)**  A tabela não guarda o conteúdo do espaço de endereçamento do processo.  \\[Imagem: Diagrama da Tabela de Processos e PCB\\]   A imagem mostra uma Process Table com entradas para os PIDs 1, 2, ..., n. Cada entrada aponta para um Process Control Block (PCB) correspondente. O PCB é uma estrutura que contém campos como Program counter, Registers, State, Priority, Address space, Open files, e Other flags.   \\--- PÁGINA 8 \\---  ## **Processos: Tabela de Controle de Processos (PCB)**  A tabela não guarda o conteúdo do espaço de endereçamento do processo.  \\[Imagem: Outra representação da Tabela de Processos\\]   Um diagrama mais abstrato mostrando vários PCBs interligados, cada um contendo informações como pid, estado, parent, children, prioridade e informações de memória.   \\--- PÁGINA 9 \\---  ## **Processos: Bloco de Controle de Processos (PCB)**  * Contém informações de contexto de cada processo (ex. ponteiros de arquivos abertos, posição do primeiro byte a ser lido em cada arquivo, etc);   * Contém informações necessárias para trazer o processo de volta, caso o S.O. tenha que tirá-lo de execução;   * Contém os estados do processo em um determinado tempo \\- Permite o rodízio de processos (time-sharing).  \\[Imagem: Estrutura do PCB\\]   Uma caixa representando o PCB com os campos: process state, process number, program counter, registers, memory limits, list of open files, e ....   \\--- PÁGINA 10 \\---  ## **Processos: Bloco de Controle de Processos (PCB)**  \\[Imagem: Lista detalhada dos campos de um PCB\\]   \\*Uma lista dos campos que podem ser encontrados em um PCB, divididos por categoria:  * **Gerenciamento de processos:** Registradores, Contador de programa, Estado do processo, Prioridade, ID do processo, etc.   * **Gerenciamento de memória:** Ponteiros para os segmentos de código, dados e pilha.   * **Gerenciamento de arquivos:** Diretório-raiz, Diretório de trabalho, Descritores de arquivos, ID do usuário, etc.\\*  \\--- PÁGINA 11 \\---  ## **Processos: Mac, Linux e Win**  \\[Imagem: Gerenciadores de Tarefas do Linux, macOS e Windows\\]   \\*A imagem mostra três capturas de tela:  * **Linux:** O comando top em um terminal, listando processos com PID, USER, PR, NI, VIRT, RES, SHR, S, %CPU, %MEM, TIME+, COMMAND.   * **macOS:** O Activity Monitor, mostrando uma lista de processos com colunas para % CPU, Memória, Disco, Rede, PID e Usuário.   * **Windows:** O Task Manager, com abas para Processos, Desempenho, etc. A aba de processos lista Apps e Processos em segundo plano com seu uso de CPU, Memória, Disco e Rede.\\*  \\--- PÁGINA 12 \\---  ## **Processos: Tabelas de Controle do Sistema Operacional**  \\[Imagem: Tabelas de controle do SO\\]   Um diagrama mostrando que o SO mantém várias tabelas para gerenciar o sistema: Memory Tables, I/O Tables, File Tables e uma Primary Process Table. A tabela de processos contém entradas para cada imagem de processo na memória.   \\--- PÁGINA 13 \\---  ## **Operações em processos**  \\--- PÁGINA 14 \\---  ## **Processos: Estados**  * **Executando:** realmente utilizando a CPU naquele momento.   * **Bloqueado:** incapaz de executar enquanto um evento externo não ocorrer.   * **Pronto:** em memória, pronto para executar (ou para continuar sua execução), apenas aguardando a disponibilidade do processador.  \\[Imagem: Diagrama de 5 estados de um processo\\]   \\*O diagrama mostra os cinco estados de um processo e as transições entre eles:  * new \\-\\> ready (admitted)   * ready \\-\\> running (scheduler dispatch)   * running \\-\\> waiting (I/O or event wait)   * running \\-\\> ready (interrupt)   * waiting \\-\\> ready (I/O or event completion)   * running \\-\\> terminated (exit)\\*  \\--- PÁGINA 15 \\---  ## **Processos: Estados**  Um processo:  * Muda seu estado de “EM EXECUÇÃO” para “EM ESPERA\\\"   * Muda seu estado de “EM EXECUÇÃO” para \\\"PRONTO\\\"   * Muda seu estado de \\\"EM ESPERA\\\" para \\\"PRONTO\\\"   * TERMINA  \\--- PÁGINA 16 \\---  ## **Processos: Criação**  * Processos Pai criam Processos Filhos, que por sua vez, criam outros processos, formando uma árvore de processos.   * Geralmente, um processo é identificado e gerenciado via um identificador de processo (pid).   * **Opções de Compartilhamento de Recursos:**     * Pais e Filhos compartilham todos os recursos.     * Filhos compartilham um subconjunto dos recursos dos pais.     * Pais e filhos não compartilham recursos.   * **Execução:**     * Pais e filhos executam concorrentemente.     * Pais aguardam o término de execução dos filhos.  \\--- PÁGINA 17 \\---  ## **Processos: Árvore de processos no Linux**  \\[Imagem: Árvore de processos do Linux\\]   Um diagrama de árvore mostrando o processo init (pid=1) como a raiz de todos os processos do sistema. A partir dele, outros processos como kthreadd, sshd, login são criados, que por sua vez criam outros processos como bash e emacs.   \\--- PÁGINA 18 \\---  ## **Processos: Criação**  * **Espaço de endereçamento**     * Filho duplica o endereço do pai.     * Filho possui um programa carregado nele.   * **Exemplo no UNIX**     * Chamada de sistema fork cria novos processos.     * Chamada de sistema exec usada após um fork para substituir o espaço de memória do processo com um novo programa.  \\[Imagem: Fluxo de criação de processo com fork e exec\\]   Um diagrama de fluxo mostrando a chamada fork(). A partir dela, o processo parent segue um caminho que o leva a wait e depois resumes. O processo child segue outro caminho, chamando exec(), depois exit(), que sinaliza o wait do pai.   \\--- PÁGINA 19 \\---  ## **Processos: Programa em C (fork/wait)**  \\[Imagem: Código em C usando fork() e wait()\\]   Um trecho de código em C que demonstra o uso de fork(). O processo pai cria um filho. Se a criação for bem-sucedida, o processo filho (pid \\== 0\\) executa o comando ls usando execlp. O processo pai (pid \\> 0\\) espera (wait(NULL)) o filho terminar e então imprime \\\"Filho completo\\\".   \\--- PÁGINA 20 \\---  ## **Processos: Término**  * Um processo executa sua última instrução e solicita ao sistema operacional a sua remoção (exit) da fila de processos.     * Mas antes coleta a saída de dados do filho para o pai (via wait).     * Os recursos do processo são desalocados pelo S.O.   * O processo pai pode terminar a execução dos processos filhos (abort).     * Processo filho excedeu os recursos alocados.     * Tarefa associada ao filho não é mais necessária.   * Se o processo pai está terminando:     * Alguns sistemas operacionais não permitem o processo filho continuar se o processo pai terminar.     * Todos os filhos são terminados \\- **terminação em cascata**.  \\--- PÁGINA 21 \\---  ## **Escalonamento de processos**  \\--- PÁGINA 22 \\---  ## **Processos: Troca de Processos pela CPU**  \\[Imagem: Diagrama de troca de contexto entre dois processos\\]   \\*O diagrama mostra duas linhas do tempo, para o processo P0 e o processo P1, e uma para o sistema operacional.  1. P0 está executing.   2. Ocorre uma interrupção ou chamada de sistema.   3. O SO salva o estado de P0 no PCB0.   4. O SO recarrega o estado de P1 do PCB1.   5. P1 começa a executing.   6. Ocorre outra interrupção.   7. O SO salva o estado de P1 no PCB1.   8. O SO recarrega o estado de P0 do PCB0.   9. P0 volta a executing.\\*  \\--- PÁGINA 23 \\---  ## **Processos: Filas para escalonamento de processos**  * **Fila de processos** \\- conjunto de todos os processos do sistema.   * **Fila de prontos** \\- conjunto dos processos residindo na memória principal, prontos e aguardando para execução (estado ready).   * **Filas de dispositivos** \\- conjunto de processos esperando por um dispositivo de E/S (estado waiting).   * Observe que os processos migram entre as várias filas, de acordo com seu estado.  \\--- PÁGINA 24 \\---  ## **Processos: Fila de prontos e Fila de Dispositivos de E/S**  \\[Imagem: Filas de processos\\]   O diagrama mostra a Fila de Prontos como uma lista ligada de PCBs. Dela saem setas para várias Filas de Dispositivos (DVD, SDD, HDD, Teclado), cada uma também sendo uma lista ligada de PCBs de processos que esperam por aquele dispositivo específico.   \\--- PÁGINA 25 \\---  ## **Processos: Representação do escalonamento de processos**  \\[Imagem: Diagrama de fluxo de escalonamento\\]   \\*Um diagrama de blocos mostrando a ready queue alimentando a CPU. A partir da CPU, um processo pode:  * Sofrer uma requisição de E/S (I/O request), indo para uma I/O queue e depois voltando para a ready queue.   * Ter seu tempo esgotado (time slice expired), voltando para a ready queue.   * Criar um filho (fork a child), e o pai pode ter que esperar.   * Ser interrompido por uma interrupção, voltando para a ready queue.\\*   * **Despachante (Dispatcher):** módulo que realiza o armazenamento e recuperação dos contextos dos processos e atualiza os PCBs.   * **Escalonador (Scheduler):** módulo que controla a mudança de estado dos processos, definindo o próximo processo a ser executado.  \\--- PÁGINA 26 \\---  ## **Processos: Despachante**  Quando a CPU realiza a troca para um outro processo, o sistema deve fazer uma **troca de contexto**, que consiste em:  * Salvar o estado do processo antigo (atualizar o PCB na RAM).   * Carregar (na CPU) o estado salvo (na RAM) do novo processo.  \\--- PÁGINA 27 \\---  ## **Processos: Escalonador de tarefas**  \\[Imagem: Caricatura de um escalonador\\]   Uma ilustração de pessoas em uma fila de banco, representando processos em uma fila esperando para serem atendidos (processados) pelos caixas (CPU).   \\--- PÁGINA 28 \\---  ## **Processos: Escalonamento**  Pode ser classificado em:  * **Escalonador de Longo Prazo (ou escalonador de jobs):**     * Seleciona quais processos devem ser carregados em memória e trazidos para a fila de prontos.     * É chamado com menos frequência (segundos, minutos).   * **Escalonador de Curto Prazo (ou escalonador da CPU):**     * Seleciona qual processo (daqueles prontos) deve ser executado em sequência e faz a alocação da CPU.     * É chamado frequentemente (\\~100ms) e deve ser rápido na escolha do processo.  \\--- PÁGINA 29 \\---  ## **Processos: Escalonamento**  *O slide repete a imagem do diagrama de fluxo de escalonamento da página 25, destacando a atuação dos diferentes escalonadores.*  \\--- PÁGINA 30 \\---  ## **Processos: Escalonamento**  Com relação ao escalonamento da CPU, pode ser classificado em:  * **Não-preemptivo:**     * Implementação mais simples do escalonador.     * O processo libera a CPU nas seguintes condições: Término da execução; ou Solicitação de operação de E/S (voluntário).   * **Preemptivo:**     * Escalonador mais complexo.     * Compartilhamento da CPU é garantido.     * Periodicamente o escalonador interrompe o processo em execução e muda-o para o estado \\\"pronto\\\".  \\--- PÁGINA 31 \\---  ## **Processos: Escalonamento**  Deve possuir um algoritmo que se preocupe com 5 regras:  * **Justiça** \\- Todos processos devem ter acesso a CPU (tempo de espera).   * **Eficiência** – buscar a máxima utilização da CPU.   * **Minimizar o Tempo de Resposta**.   * **Turnaround** \\- Minimiza os usuários batch. Tempo para conclusão do processo.   * **Throughput** – Maximizar o número de jobs processados.  Como esta escolha pode ser feita?  \\--- PÁGINA 32 \\---  ## **Processos**  \\[Imagem: Diagrama de rajadas de CPU e E/S\\]   O diagrama mostra a vida de um processo como uma alternância entre rajadas de CPU (CPU burst) e rajadas de espera por E/S (I/O burst).   Podem ser descritos como:  * **I/O-bound:** Gastam mais tempo fazendo E/S do que computação.   * **CPU-bound:** Gastam mais tempo com computação.  \\--- PÁGINA 33 \\---  ## **Processos**  Podem ser classificados por:  * **Uso de recursos:** temos os processos convencionais e os de tempo real (de sistema).     * No Linux, os processos de tempo real recebem prioridade entre 1 e 99, enquanto os processos convencionais recebem prioridade entre 100 e 139 (padrão 120).   * **Tipo de execução:** temos os interativos, em série ou tempo real.  \\--- PÁGINA 34 \\---  ## **Processos**  \\[Imagem: Saída do comando top com destaque\\]   A imagem mostra novamente a saída do comando top. Destaques em texto indicam: S \\- Em série, I \\- Interativos, R \\- Tempo real.   \\--- PÁGINA 35 \\---  ## **Processos: Escalonador de médio prazo (Swapping)**  \\[Imagem: Diagrama de Swapping\\]   O diagrama mostra o processo de swapping. Processos parcialmente executados podem ser movidos da memória (ready queue) para o disco (swapped-out processes) e depois trazidos de volta (swap in) para a ready queue quando necessário.   OBS.: alguns sistemas de tempo compartilhado não possuem Escalonador de Longo Prazo, como o Unix e o MS Windows.  \\--- PÁGINA 36 \\---  ## **Processos: Troca de contexto**  * Quando a CPU realiza a troca para um outro processo, o sistema deve fazer uma troca de contexto:     * salvar o estado do processo antigo (atualizar o PCB na RAM)     * carregar (na CPU) o estado salvo (na RAM) do novo processo   * O contexto de um processo é representado no PCB.   * O tempo de troca de contexto gera overhead (sobrecarga).   * O sistema não trabalha de forma útil durante a troca.   * Tempo dependente do suporte de hardware.  \\--- PÁGINA 37 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 2\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulo 3\\.  \\--- PÁGINA 38 \\---   Slide final com o logo da universidade e contato do professor.