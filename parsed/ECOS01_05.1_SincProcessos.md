\\--- PÁGINA 1 \\---  # **Sistemas Operacionais**  ## **Sincronização de Processos**  ### **Parte 1**  Prof. Otávio Gomes   otavio.gomes@unifei.edu.br   \\--- PÁGINA 2 \\---  ## **Condições de corrida e o problema da Seção Crítica**  * Acesso concorrente a dados compartilhados pode resultar em inconsistências;   * **Condições de corrida (race conditions):**     * Situação onde dois ou mais processos acessam e manipulam recursos compartilhados simultaneamente.   * **Seção crítica:** N processos competem para usar alguma estrutura de dados compartilhada.  \\[Imagem: Conceito de Seção Crítica\\]   A imagem mostra dois cenários. O de cima, marcado com um \\\"X\\\" de incorreto, exibe uma \\\"Critical Section\\\" com quatro processos (P1, P2, P3, P4) dentro dela ao mesmo tempo. O cenário de baixo, correto, mostra a \\\"Critical Section\\\" com apenas um processo (P1) dentro, enquanto os outros três esperam do lado de fora.   \\--- PÁGINA 3 \\---  ## **Condições de corrida e o problema da Seção Crítica**  \\[Imagem: Exemplo de Condição de Corrida num Spooler\\]   A imagem ilustra uma condição de corrida num diretório de spooler de impressão. Duas variáveis de índice, in=7 e out=4, controlam a fila. O Process A lê o valor de in para adicionar um novo trabalho. Antes de conseguir atualizar o índice, é interrompido. O Process B também lê in, adiciona seu trabalho e atualiza o índice. Quando o Process A retorna, ele usa o valor antigo de in, potencialmente sobrescrevendo o trabalho do Process B ou causando inconsistência na fila.   \\--- PÁGINA 4 \\---  ## **Condições de corrida e o problema da Seção Crítica**  * Acesso concorrente a dados compartilhados pode resultar em inconsistências;   * **Condições de corrida (race conditions):** Situação onde dois ou mais processos acessam e manipulam recursos compartilhados simultaneamente.   * **Seção crítica:** N processos competem para usar alguma estrutura de dados compartilhada. Cada processo possui uma seção crítica de código, onde há a manipulação dos seus dados.   * Para resolver a questão de seção crítica cada processo deve pedir permissão para entrar na região crítica, após a utilização da seção crítica, seguir com a execução das ações.   * Especialmente difícil resolver este problema em kernel preemptivo.  \\--- PÁGINA 5 \\---  ## **Seção crítica: Solução \\- Requisitos**  * Uma boa solução para o problema da seção crítica deve satisfazer os seguintes requisitos:     1. **Exclusão mútua:** se um processo i (Pi) está na seção crítica, nenhum outro processo pode entrar nela;  \\--- PÁGINA 6 \\---  ## **Seção crítica: Solução \\- Requisitos**  \\[Imagem: Linha do tempo da Exclusão Mútua\\]   \\*O diagrama mostra uma linha do tempo para dois processos, A e B.  * Em T₁, o Processo A entra na sua região crítica.   * Em T₂, o Processo B tenta entrar na sua região crítica, mas é bloqueado porque A já está lá.   * Em T₃, o Processo A sai da sua região crítica, o que desbloqueia B, permitindo que ele entre.   * Em T₄, o Processo B sai da sua região crítica.\\*   * **Exclusão mútua** é garantir que um processo não terá acesso a uma região crítica quando outro processo estiver utilizando esta região.   * Pode gerar uma fila de clientes para acessar a Região Crítica (overhead).  \\--- PÁGINA 7 \\---  ## **Seção crítica: Solução \\- Requisitos**  * Uma boa solução para o problema da seção crítica deve satisfazer os seguintes requisitos:     1. **Exclusão mútua:** se um processo i (Pi) está na seção crítica, nenhum outro processo pode entrar nela;     2. **Progresso garantido:** se nenhum outro processo está na seção crítica, um processo que tente fazê-lo não pode ser detido indefinidamente;  \\--- PÁGINA 8 \\---  ## **Seção crítica: Solução \\- Requisitos**  * Uma boa solução para o problema da seção crítica deve satisfazer os seguintes requisitos:     1. **Exclusão mútua**     2. **Progresso garantido**     3. **Espera limitada:** se um processo deseja entrar na seção crítica, há um limite na quantidade de vezes que outros processos que podem entrar nela antes dele (evitar a inanição \\- starvation);  \\--- PÁGINA 9 \\---  ## **Seção crítica: Solução \\- Requisitos**  * Uma boa solução para o problema da seção crítica deve satisfazer os seguintes requisitos:     1. **Exclusão mútua**     2. **Progresso garantido**     3. **Espera limitada**     4. **Independência da arquitetura:** o processo não pode funcionar somente se estiver sendo executado em uma configuração específica de dispositivo, por exemplo: quantidade de núcleos e/ou frequência determinados.  *Observação: Alguns autores omitem este último requisito.*  \\--- PÁGINA 10 \\---  ## **Seção crítica: Solução \\- Requisitos**  *O acesso à região crítica pode envolver tanto processos, quanto threads.*  \\--- PÁGINA 11 \\---  ## **Comunicação entre Processos: InterProcess Communication (IPC)**  * Frequentemente processos precisam se comunicar.   * A comunicação é mais eficiente se for estruturada e não utilizar interrupções.   * Questões importantes:     * Como um processo passa informação para outro?     * Como garantir que processos não invadam espaços uns dos outros, nem entrem em conflito?     * Qual a sequência adequada quando existe dependência entre processos?  \\--- PÁGINA 12 \\---  ## **Sincronização**  \\[Imagem: Tabela \\\"Exemplo da Geladeira\\\"\\]   \\*A tabela descreve um cenário com duas pessoas, A e B, que podem acabar comprando leite duas vezes por falta de sincronização.  * 6h00: A olha a geladeira e vê que não tem leite.   * 6h05: A sai para comprar.   * 6h10: B olha a geladeira e também vê que não tem leite (A ainda não voltou).   * 6h15: B também sai para comprar.   * Resultado: Ambos chegam em casa com leite.\\*  \\--- PÁGINA 13 \\---  ## **Sincronização**  *A tabela do slide anterior é mostrada novamente, agora ao lado de uma tabela com as regras de solução:*  * **Regra 1\\. Trancar antes de utilizar:** Deixar um aviso (Ex: \\\"Fui comprar leite\\\").   * **Regra 2\\. Destrancar quando terminar:** Retirar o aviso.   * **Regra 3\\. Esperar se estiver trancado:** Não sair para comprar se houver aviso.  \\--- PÁGINA 14 \\---  ## **Sincronização entre processos**  * A sincronização dos recursos do computador é realizada pelo S.O. multitarefas e é feita tanto para dados (para manter dados em integridade) quanto para processos (evitar conflito na utilização dos recursos).   * Os mecanismos para controle de sincronização, dentre outros, podem ser:     1. **Barreiras:** criadas e gerenciadas pelo programa, o programa entra em estado de espera até que todos os processos pertencentes ao mesmo programa também entrem neste estado;  \\--- PÁGINA 15 \\---  ## **Sincronização entre processos**  2. **Semáforos:** podem ser implementados tanto pelo S.O. quanto pelo programa; consistem em variáveis de controle que indicam quantos processos podem compartilhar um recurso;   3. **Trava (Lock):**      * **simples** \\- impede a utilização do recurso por outro processo;      * **especial** \\- sinaliza quando se tenta utilizar um recurso já em uso; e      * **compartilhada** \\- um único processo recebe permissão de leitura e escrita e os demais somente de leitura.  *A barreira e o semáforo permitem compartilhamento de recurso, a trava simples não. A sincronia exige a existência de uma instrução capaz de ao mesmo tempo \\\"verificar e, se possível, travar\\\".*  \\--- PÁGINA 16 \\---  ## **Seção crítica: Propostas de Solução**  * Espera ocupada (busy waiting)   * Sleep / WakeUp (primitivas \\- chamadas de sistema)   * Semáforos (variável de controle)   * Monitores (primitiva de alto nível)   * Troca de Mensagens  \\--- PÁGINA 17 \\---   Este slide repete a lista de Requisitos da Solução para a Seção Crítica da página 9\\.   \\--- PÁGINA 18 \\---   Este slide repete a lista de Propostas de Solução da página 16\\.   \\--- PÁGINA 19 \\---  ## **Seção crítica: Espera Ocupada**  \\[Imagem: Caricatura de Espera Ocupada\\]   Uma ilustração de pessoas em uma fila de atendimento (como um banco ou cartório), olhando constantemente para o painel de senhas, esperando sua vez. Isso representa um processo que consome tempo de CPU verificando repetidamente uma condição.  * Consiste na constante verificação de um valor.   * Gera desperdício de tempo da CPU.   * Soluções para exclusão mútua através de espera ocupada:     1. Desabilitar Interrupções;     2. Variáveis de trancamento (Lock);     3. Estrita alternância (Turn);     4. Solução de Peterson e instrução TSL.  \\--- PÁGINA 20 \\---  ## **Espera Ocupada: 1\\) Desabilitar Interrupções**  * Cada processo desabilita todas as interrupções (inclusive a do relógio) ao entrar na região crítica;   * Com as interrupções desabilitadas, a CPU não realiza chaveamento entre os processos;  \\--- PÁGINA 21 \\---  ## **Espera Ocupada: 1\\) Desabilitar Interrupções**  Análise de situações-problema:  * Em sistemas com várias CPUs, desabilitar interrupções de uma CPU não evita que outras acessem a memória compartilhada;   * Não é uma solução segura, pois um processo pode esquecer de reabilitar suas interrupções, gerando inanição;   * Funciona bem somente em ambientes monoprocessados.  *Uma tabela indica que esta solução viola o Progresso Garantido e a Independência da Arquitetura.*  \\--- PÁGINA 22 \\---  ## **Espera Ocupada: 2\\) Variáveis de trancamento (mutex lock)**  * Os sistemas operacionais oferecem soluções em software para o problema da região crítica. O mais simples é a trava mutex, que é utilizado para proteger regiões críticas e prevenir condições de corrida.   * O processo precisa realizar o trancamento da seção crítica antes de entrar nela e realiza seu destravamento após sair dela.  \\--- PÁGINA 23 \\---  ## **Espera Ocupada: 2\\) Variáveis de trancamento (mutex lock)**  \\[Imagem: Pseudocódigo com variável de lock\\]   O slide mostra um pseudocódigo para dois processos, A e B. Ambos executam um laço while(lock \\!= 0); antes de entrar na região crítica. Ao entrar, definem lock=1 e, ao sair, lock=0.   \\--- PÁGINA 24 \\---   Este slide repete a imagem de pseudocódigo da página 23\\.   \\--- PÁGINA 25 \\---  ## **Espera Ocupada: 2\\) Variáveis de trancamento (mutex lock)**  Análise de uma situação-problema:  1. Mudança de contexto no processo A após a verificação de lock==0; (mas antes de definir lock=1).   2. Execução do processo B, que também vê lock==0, define lock=1 e entra na região crítica.   3. Retorno do processo A ao processador, que agora também define lock=1 e entra na região crítica.   4. Os dois processos acessam a região crítica.  *Uma tabela indica que esta solução viola a Exclusão Mútua.*  \\--- PÁGINA 26 \\---  ## **Espera Ocupada: 3\\) Estrita alternância**  \\[Imagem: Pseudocódigo com variável turn\\]   O slide mostra um pseudocódigo para dois processos, A e B. Uma variável compartilhada turn controla qual processo pode entrar na região crítica. O Processo A só entra se turn \\== 0, e ao sair, define turn \\= 1\\. O Processo B só entra se turn \\== 1, e ao sair, define turn \\= 0\\.   \\--- PÁGINA 27 \\---  ## **Espera Ocupada: 3\\) Estrita alternância**  \\[Imagem: Diagrama de fluxo da Estrita Alternância\\]   Um diagrama ilustra o fluxo. Para o Processo Pi entrar na região crítica, a variável Turn deve ser igual a i. Ao sair, ele define Turn como j, passando a vez para o Processo Pj.   \\--- PÁGINA 28 \\---  ## **Espera Ocupada: 3\\) Estrita alternância**  * Conhecida como alternância rigorosa.   * Nunca um processo entra duas vezes seguidas em uma região crítica.  \\--- PÁGINA 29 \\---  ## **Espera Ocupada: 3\\) Estrita alternância**  *Uma tabela indica que esta solução viola o Progresso Garantido. Se um processo não quiser entrar na sua região crítica, o outro ficará bloqueado para sempre, mesmo que a região esteja livre.*  \\--- PÁGINA 30 \\---  ## **Espera Ocupada: 4\\) Solução de Peterson**  * Antes de entrar na Região Crítica (RC), cada processo chama a função enter\\_region, demonstrando seu interesse em entrar na RC;   * Somente no retorno da função enter\\_region é que o processo entra na RC;   * Com a utilização desta função, o processo espera até que seja seguro entrar na RC.   * Após terminar a execução na RC, ele chama a função leave\\_region.  \\--- PÁGINA 31 \\---   Este slide repete a estrutura geral da Solução de Peterson da página 30\\.   \\--- PÁGINA 32 \\---  ## **Espera Ocupada: 4\\) Solução de Peterson**  \\[Imagem: Código da Solução de Peterson\\]   O slide mostra o código para as funções enter\\_region e leave\\_region. A solução utiliza um array interested para indicar quais processos querem entrar e uma variável turn para resolver empates, garantindo a exclusão mútua e o progresso.   \\--- PÁGINA 33 \\---  ## **Espera Ocupada: 4\\) Solução de Peterson \\+ TSL**  \\[Imagem: Diagrama da instrução Test-and-Set Lock (TSL)\\]   O slide mostra o pseudocódigo da rotina enter\\_region usando a instrução de hardware TSL. A instrução atomicamente testa o valor de uma variável LOCK e a define como TRUE. O processo entra em um laço se o valor anterior já era TRUE. A rotina leave\\_region simplesmente define LOCK como FALSE.   \\--- PÁGINA 34 \\---  ## **Espera Ocupada: 4\\) Solução de Peterson \\+ TSL**  * Utiliza suporte de hardware \\- TSL (Test-And-Set Lock).   * Operação indivisível (atômica) \\- Bloqueia o barramento de memória.   * No Intel x86 TSL é XCHG (Exchange Data).  *Uma tabela indica que esta solução satisfaz a Exclusão Mútua e o Progresso Garantido, mas viola a Espera Limitada, pois não há garantia sobre qual processo na fila será o próximo.*  \\--- PÁGINA 35 \\---  ## **Seção crítica: Espera Ocupada (Resumo)**  * Consiste na constante verificação de um valor (laço de espera).   * Gera desperdício de tempo da CPU.   * Soluções para exclusão mútua através de espera ocupada:     1. Desabilitar Interrupções;     2. Variáveis de trancamento (Lock);     3. Estrita alternância (Turn);     4. Solução de Peterson e a instrução TSL.  *A tabela de requisitos é mostrada novamente.*  \\--- PÁGINA 36 \\---  ## **Bibliografia**  * TANENBAUM, Andrew S; BOS, Herbert. **Sistemas operacionais modernos.** 4a ed. São Paulo: Pearson Education do Brasil, 2016\\. Capítulo 2\\.   * DEITEL, H.M; DEITEL, P.J; CHOFFNES,D.R. **Sistemas Operacionais.** 3a ed. São Paulo: Pearson Prentice Hall, 2005\\. Capítulos 5 e 6\\.  \\--- PÁGINA 37 \\---   Slide final com o logo da universidade e contato do professor.